<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Software Design and Architecture Patterns</title><meta name=description content=":clap: What. Does. The. Client. Want.
Web Applications vs Local Application

scale&mdash;what levels of functionality and access do we want
training
speed

SOLID principles
SOLID principles is a set of OOP principles; its kinda famous but encourages mindless braindead Java devs.

Single Responsibility: that a class should have only one clearly defined thing it represents, and the class should only change IFF the underlying spec regarding that thing changes

Easy pitfalls: mixing PERSISTENCE LOGIC with BUSINESS LOGIC (db should be moved to a separate class like ThingProvider/ThingPersistence)


Open-Close Principle: classes should be easily extendable and closed to modification

&ldquo;we should be able to add new functionality without touching what&rsquo;s written&rdquo;
so like interfaces are nice


Liskov Substitution Principle: subclasses should act like base classes (and more); good inheritance systems should have this built in
Interface Segregation Principle: you should build lots of interfaces + sub-interfaces based on what clients are and will need, such that a client only has to extend precisely the amount needed to do their job
Dependency Inversion Principle: when possible, depend on abstract classes or interfaces and not their implementations

Dependency Injection

&ldquo;Dependency Injection&rdquo; is a 25-dollar term for a 5-cent concept. [&mldr;] Dependency injection means giving an object its instance variables. [&mldr;]."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Software Design and Architecture Patterns</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#web-applications-vs-local-application>Web Applications vs Local Application</a></li><li><a href=#solid-principles>SOLID principles</a><ul><li><a href=#dependency-injection>Dependency Injection</a></li></ul></li><li><a href=#shared-nothing-architecture>Shared-nothing architecture</a></li></ul></nav></aside><main><article><div><p>:clap: What. Does. The. Client. Want.</p><h2 id=web-applications-vs-local-application>Web Applications vs Local Application</h2><ul><li>scale&mdash;what levels of functionality and access do we want</li><li>training</li><li>speed</li></ul><h2 id=solid-principles>SOLID principles</h2><p><a href=#solid-principles>SOLID principles</a> is a set of OOP principles; its kinda famous but encourages mindless braindead Java devs.</p><ul><li><strong>Single Responsibility</strong>: that a class should have only one clearly defined thing it represents, and the class should only change IFF the underlying spec regarding that thing changes<ul><li>Easy pitfalls: mixing PERSISTENCE LOGIC with BUSINESS LOGIC (db should be moved to a separate class like ThingProvider/ThingPersistence)</li></ul></li><li><strong>Open-Close Principle</strong>: classes should be easily extendable and closed to modification<ul><li>&ldquo;we should be able to add new functionality without touching what&rsquo;s written&rdquo;</li><li>so like interfaces are nice</li></ul></li><li><strong>Liskov Substitution Principle</strong>: subclasses should act like base classes (and more); good inheritance systems should have this built in</li><li><strong>Interface Segregation Principle</strong>: you should build lots of interfaces + sub-interfaces based on what clients are and will need, such that a client only has to extend precisely the amount needed to do their job</li><li><strong>Dependency Inversion Principle</strong>: when possible, depend on abstract classes or interfaces and not their implementations</li></ul><h3 id=dependency-injection>Dependency Injection</h3><blockquote><p>&ldquo;Dependency Injection&rdquo; is a 25-dollar term for a 5-cent concept. [&mldr;] Dependency injection means giving an object its instance variables. [&mldr;].</p></blockquote><p>Blame this for all the fucking Factory classes.</p><p>Basically having a factory (or just a fancy-enough constructor) to give a class all the right instantiations of the things it needs instead of having the class construct them inside.</p><p>You do this because 1) the class can then depend on more abstract interfaces 2) you can test shit easier by constructing all the necessary parts</p><h2 id=shared-nothing-architecture>Shared-nothing architecture</h2><p>A <a href=#shared-nothing-architecture>shared-nothing architecture</a> is a type of distributed computing software architecture which ensures that no single shard shares/overlaps resources with others (i.e. needing shared memory, etc.)</p><p>So no mutexes; and no single-points of failure (i.e. we don&rsquo;t dependent on a central node always working).</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>