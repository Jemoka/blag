<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Approximation Algorithms</title>
<meta name=description content="Probabilistically Checkable Proofs
Every statement that has a polynomial time checkable proof has such a proof where the verifier only reads \(O(1)\) (constant) bits of the proof such hat&mldr;

perfect completeness: correct statements will be accepted with probability 1
soundness: false statements will be rejected with probability 0.99 (with epsilon as the reading constant increases)

PCP Theorem
For some constant \(\alpha > 0\), and for ever language \(L \in NP\), there exists a polynomial-time computable function that makes every input \(x\) into a 3cnf-formula \(f(x)\) such that&mldr;"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Approximation Algorithms</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#probabilistically-checkable-proofs>Probabilistically Checkable Proofs</a><ul><li><a href=#pcp-theorem>PCP Theorem</a></li></ul></li><li><a href=#provability>Provability</a><ul><li><a href=#interactive-proofs>Interactive Proofs</a></li><li><a href=#graph-non-isomorphism>Graph Non-Isomorphism</a></li></ul></li><li><a href=#approximation-hardness>Approximation Hardness</a><ul><li><a href=#approximation-preserving-reductions>approximation preserving reductions</a></li></ul></li><li><a href=#example>example</a><ul><li><a href=#vertex-cover--kbhnp-complete-dot-md><a href=HAHAHUGOSHORTCODE98s5HBHB>vertex cover</a></a></li><li><a href=#max-sat>Max-SAT</a></li><li><a href=#clique-problem--kbhnon-deterministic-turing-machines-dot-md><a href=HAHAHUGOSHORTCODE98s10HBHB>clique problem</a></a></li></ul></li></ul></nav></aside><main><article><div><h2 id=probabilistically-checkable-proofs>Probabilistically Checkable Proofs</h2><p>Every statement that has a <strong>polynomial time checkable</strong> proof has such a proof where the verifier only reads \(O(1)\) (constant) bits of the proof such hat&mldr;</p><ul><li><strong>perfect completeness</strong>: correct statements will be accepted with probability 1</li><li><strong>soundness</strong>: false statements will be rejected with probability 0.99 (with epsilon as the reading constant increases)</li></ul><h3 id=pcp-theorem>PCP Theorem</h3><p>For some constant \(\alpha > 0\), and for ever language \(L \in NP\), there exists a polynomial-time <a href=/posts/kbhmapping_reduction/#computable-function>computable function</a> that makes every input \(x\) into a <a href=/posts/kbhnon_deterministic_turing_machines/#3cnf-formula>3cnf-formula</a> \(f(x)\) such that&mldr;</p><ol><li>if \(x \in L\), then \(f(x) \in \text{SAT}\)</li><li>if \(x \neq L\), then there is no assignment that satisfies more than \(\qty(1-\alpha)\) fraction of \(f(x)\) clauses</li></ol><p>That is, a sufficiently good approximation of <a href=#max-sat>Max-SAT</a> will imply \(P = NP\) (because we cloud just us that <a href=#max-sat>Max-SAT</a> to disambiguate whether or not \(f(x)\) has a maximum satisfiable over the line of \((1-\alpha)\) and declare it in or out of the language.</p><h2 id=provability>Provability</h2><p>By definition everything in \(NP\) has a short and checkable proof (in polynomial time) &mldr;same can go for coNP and <a href=/posts/kbhspace_complexity/#pspace>PSPACE</a> if we <strong>add interaction</strong>.</p><h3 id=interactive-proofs>Interactive Proofs</h3><p>We have prover \(P\) and verifier \(V\). The \(V\) asks \(P\) for membership statements, and \(P\) responds with statements. These proofs can be used to prove membership in very powerful languages.</p><h3 id=graph-non-isomorphism>Graph Non-Isomorphism</h3><p>A graph \(G\) and \(H\) are <a href=/posts/kbhisomorphism/>isomorphic</a> if you can rename \(G\) to get \(H\) (i.e. they are same up to renaming).</p><ul><li>GraphIsomorphism = {(G,H) | G and H are isomorphic}</li><li>GraphNonIsomorphism = {(G,H) | G and H are not isomorphic}</li></ul><p>GraphIsomorphism is in NP. But, how do we show that two things are <strong>not</strong> isomorphic?</p><h2 id=approximation-hardness>Approximation Hardness</h2><p>For particular problems, we can&rsquo;t even <strong>approximate</strong> it well enough.</p><p>Interestingly, for many problems, we know exactly what the correct approximation factor is; we even know what the approximation boundary is, so beyond this line we know we can&rsquo;t solve it unless \(P= NP\).</p><p>To show these results, we will need approximation-preserving reductions</p><h3 id=approximation-preserving-reductions>approximation preserving reductions</h3><p>for instance, <a href=/posts/kbhnon_deterministic_turing_machines/#clique-problem>clique problem</a> (\(3SAT \leq_{P} \text{CLIQUE}\)) is <strong>very</strong> approximation preserving because the size of the clique corresponds exactly to the number of clauses you can satisfy.</p><p>However, (\(\text{IS} \leq_{P} \text{{Vertex-Cover}}\)) is super not approximation preserving; recall that our argument is that \(V - IS\) is a vertex cover, meaning \(\qty(G, k) \Leftrightarrow (G, |V|-k)\) is the sizes of the independent set and vertex covers respectively.</p><p>These are not good approximations of each other; suppose the minimum vertex cover is \(k \ll n\), this make the maximum independent set \(n-k\). An approximation of independent set will give a vertex cover size of \(\frac{n}{c}\) (since \(k\) is, as said before, very small), which means the approximate VC given would be \(n - \frac{n}{c}\) which may not be anywhere near \(n-k\).</p><h2 id=example>example</h2><h3 id=vertex-cover--kbhnp-complete-dot-md><a href=/posts/kbhnp_complete/#vertex-cover>vertex cover</a></h3><p>Recall <a href=/posts/kbhnp_complete/#vertex-cover>vertex cover</a> problem:</p><p>we want to find the smallest <a href=/posts/kbhnp_complete/#vertex-cover>vertex cover</a>&mdash;this could be approximated greedily which will find a <a href=/posts/kbhnp_complete/#vertex-cover>vertex cover</a> which is at most twice as large as the original (a &ldquo;two-approximation&rdquo;)</p><p><strong>the algorithm</strong>: set \(C = \emptyset\), and while there exists an uncovered edge \(e\), add both endpoints of such an \(e\) to \(C\)</p><p><strong>prove</strong>:</p><ol><li>it will work because for every uncovered edge, at least one of its endpoints is in the minimal vertex cover; so we add be greedy and just add both</li><li>it 2x because we at most add 2x &ldquo;extra&rdquo; verticies</li></ol><h3 id=max-sat>Max-SAT</h3><p>given a <a href=/posts/kbhnon_deterministic_turing_machines/#3cnf-formula>cnf-formula</a> (not just 3cnf), how many clauses can be satisfied? a <strong>maximization problem</strong> because we want to satisfy the maximal amount of clauses.</p><p>approximation: we can always satisfy a constant frication of all of the clauses: that is, when all clauses have at least 3 unique literals, we can satisfy at least 7/8 of all the clauses (i.e. we will get to \(\geq \frac{7}{8}\) clauses of the clauses than optimal solution).</p><p>We can&rsquo;t solve this even further (i.e. we can&rsquo;t solve up to \(\frac{7}{8}+\varepsilon\) for any \(\varepsilon > 0\)) without \(P = NP\). see <a href=#pcp-theorem>PCP Theorem</a></p><h3 id=clique-problem--kbhnon-deterministic-turing-machines-dot-md><a href=/posts/kbhnon_deterministic_turing_machines/#clique-problem>clique problem</a></h3><p>for other problems (such as cliques), no constant approximation may even occur</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>