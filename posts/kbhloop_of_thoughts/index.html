<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Project Proposal: Lookahead Sampler</title>
<meta name=description content="Introduction and Background Recent advances of language models (LMs) introduced the possibility of in-context, few or zero-shot reasoning ((Brown et al. 2020)) using LMs without much or any fine tuning.
Classically, LM decoding takes place using a left-to-right fashion, auto-regressively resolving one token at a time by sampling from the output distribution of possible next words. This simple approach has yielded significant advancements across most areas of LM research, but is subject to some notable drawbacks."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Project Proposal: Lookahead Sampler</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#introduction-and-background>Introduction and Background</a></li><li><a href=#proposed-approach>Proposed Approach</a><ul><li><a href=#definitions-and-prompts>Definitions and Prompts</a></li><li><a href=#pomdp-formulation>POMDP Formulation</a></li><li><a href=#decoding>Decoding</a></li></ul></li><li><a href=#plan-for-evaluation>Plan for Evaluation</a></li></ul></nav></aside><main><article><div><h2 id=introduction-and-background>Introduction and Background</h2><p>Recent advances of language models (LMs) introduced the possibility of in-context, few or zero-shot reasoning ((<a href=#citeproc_bib_item_1>Brown et al. 2020</a>)) using LMs without much or any fine tuning.</p><p>Classically, LM decoding takes place using a left-to-right fashion, auto-regressively resolving one token at a time by sampling from the output distribution of possible next words. This simple approach has yielded significant advancements across most areas of LM research, but is subject to some notable drawbacks.</p><p>Most importantly, (<a href=#citeproc_bib_item_3>Holtzman et al. 2020</a>) highlights the problem of &ldquo;de-generation&rdquo;, whereby, because of the non-backtracking nature of auto-regression, naive maximizations of sequence likelihood results in a most likely sub-phrase being repeated. Yet, (<a href=#citeproc_bib_item_2>Finlayson et al. 2023</a>) has shown that one core reason why this de-generative process occurs due to the dramatically constraining projection which the softmax activation causes at the end of LM decoding. Therefore, especially as model size scales, it is possible that the latent information of a LM contains a lot more information than can be posited from the final token output.</p><p>Recent work in LM agents have taken steps to solve more complex problems with LMs by attempting to extract latent reasoning by eliciting prompt-level natural language responses. The simplest approach, named &ldquo;chain-of-thoughts&rdquo; (CoT), involves forcing the LM at decode time to begin the sequence with natural language reasoning about its actions ((<a href=#citeproc_bib_item_8>Wei et al. 2022</a>)). The fairly simple method has contributed to the creation of powerful language agents ((<a href=#citeproc_bib_item_10>Yao, Zhao, et al. 2023</a>)) that can reason about complex actions.</p><p>Yet more recently, (<a href=#citeproc_bib_item_9>Yao, Yu, et al. 2023</a>) presents a decomposition of the chain-of-thoughts approach by combining LLM decoding with classic approaches in search and planning. This &ldquo;tree-of-thoughts&rdquo; (ToT) formulation breaks a possible valid response into a finite-horizon planning problem, whereby at each time an I.I.D. sampling of LM output is decoded, and the optimal seed sequence for each next time stamp decided through the LM&rsquo;s own scoring of such samples via self-reflection by depth-first (DFS) or breath-first (BFS) traversal of the sampling tree.</p><p>By combining explicit planning and LM reasoning, this approach achieved state-of-the-art results in difficult natural-language tasks such as a crossword. However, the approach has a few limitations yet to be explored which may confer increased reasoning advantage.</p><p>First, the ToT formulation still leverages a decoding approach at a paragraph level, meaning its output thoughts are still subject to the degeneration concerns outlined before. Furthermore, the paragraph level decoding means that a successful decoding with ToT requires the generation of many such &ldquo;thoughts&rdquo; to create an adequate sampling of the latent state space.</p><p>Second, ToT does not incorporate any form of preferential planning between different &ldquo;though&rdquo; states, and instead opts for a fixed search scheme such as DFS to decode the best possible output sequences&mdash;in contrast to dynamic approaches which preferentially explore sequences of high probability of success.</p><p>To address these limitations, we propose the Lookahead Sampler (LS), a LM inference scheme which aims to leverage the LM self-reflective planning aspects of ToT, but formulate the problem explicitly as 1) a token-level decoding decision-making scheme with backtracking which 2) is solved via an online search formulation. To do this, we formulate the task of self-reflective language agent decoding as a POMDP ((<a href=#citeproc_bib_item_4>Kaelbling, Littman, and Cassandra 1998</a>)), and propose strategies to best solve this system.</p><p>The key underlying assumption of the proposed LS scheme involves the claim that LMs are able to make judgments about the coherence of a sequence in latent space which is collapsed during output token simplex projection. This assumption is supported by the existence of reinforcement learning formulations of LM-on-LM output verification&mdash;both for reasoning ((<a href=#citeproc_bib_item_7>Verma et al. 2022</a>)) and hallucination ((<a href=#citeproc_bib_item_6>Liu et al. 2022</a>))&ndash;as well as the ToS approach itself.</p><p>We leverage this assumption by, similar to ToT, using the LM&rsquo;s evaluation of the likelihood of a sequence (similar to LM &ldquo;scoring&rdquo; of a &ldquo;thought&rdquo; in ToT) as a heuristic for the coherence and reasoning within a subsequence of LM output. Yet, differing from ToT, we explicitly formulate this scoring by an LM as an &ldquo;observation&rdquo; from an unobservable underlying latent understanding of the input sequence.</p><h2 id=proposed-approach>Proposed Approach</h2><h3 id=definitions-and-prompts>Definitions and Prompts</h3><p>To formulate the approach, let us first formalize LM decoding. Let \(\tau\) a sequence of tokens in vocab, formulating a trajectory which we combine, if complete, to call a &ldquo;sentence&rdquo;:</p><p>\begin{equation}
\tau_{i} = [w_1, \dots, w_{n}], w_{j} \in V
\end{equation}</p><p>Let an LM with parameters \(\theta\) be called \(p_{\theta}\), the task of LM decoding is then sampling a word from the next word distribution \(w_{n+1} \in W_{n+1}\) given our current trajectory where:</p><p>\begin{equation}
W_{n+1} = p_{\theta}( \cdot | \tau_{i})
\end{equation}</p><p>Following ToT&rsquo;s value formulation, we label an output trajectory using one of three situations: &ldquo;sure&rdquo; \(c_0\), &ldquo;likely&rdquo; \(c_1\), &ldquo;impossible&rdquo; \(c_2\).</p><p>Finally, we can now formulate our space as \(S = C \times \tau\). For instance, let</p><p>\begin{equation}
\tau_{0} = [``Jack", ``is", ``chicken"]
\end{equation}</p><p>then, the state: \((\tau_{0}, c_1)\) can be interpreted as the situation that &ldquo;Jack is likely a chicken&rdquo;.</p><p>We further define a few LM prompts (i.e. functions over \(\tau\)) that will be useful in our discussion of the formulation.</p><p>we define the <code>conditioning</code> prompt as:</p><p>\begin{equation}
\tau_{cond}(\tau_{i}, \tau_{j}, c_{i}) = \text{if } \tau_{i} \text{ is } c_{i} \text{, then, } \tau_{j} \text{ is }
\end{equation}</p><p>and the <code>evaluation</code> prompt as:</p><p>\begin{equation}
\tau_{eval}(\tau_{i}) = \tau_{i} \text{ is }
\end{equation}</p><p>these prompts will be used in the following section to formulate our transition and observation functions, an could be thought of similarly as analogous to ToT&rsquo;s instantiation of the &ldquo;value&rdquo; function.</p><h3 id=pomdp-formulation>POMDP Formulation</h3><p>We formulate the <strong>state</strong>, as mentioned above, as \(S = C \times \tau\). As we desire to formulate LS as an LM decoding scheme, we have <strong>action</strong> space being discrete over three possible decoding actions &mdash; &ldquo;sample next token&rdquo; \(a_0\), &ldquo;delete previous token&rdquo; \(a_1\), &ldquo;submit&rdquo; \(a_2\). Let \(A(a, \tau_{i}) \in \tau\) be the function which applies the action (i.e. deleting a token, sampling a token from LLM) onto a given trajectory. \(A(a_2, \tau_{i}) = \tau_{i}\).</p><p>We assign <strong>reward</strong> as follows:</p><p>\begin{equation}
R((\tau, c), a) = \begin{cases}
+1, \text{where, }c = c_0, a=a_2 \\
-1, \text{where, }c = c_2, a=a_2\\
0, \text{otherwise}
\end{cases}
\end{equation}</p><p>indeed, importantly, no other agents apart from the LM itself is responsible for assigning this reward&mdash;making this a self-reflection scheme.</p><p>We leverage the <code>conditioning</code> prompt above to formulate our transition function. The motivation for this formulation is similar to the CoT&mdash;that leveraging stepwise thinking in LMs is easier than one-shot reasoning. Hence, we give:</p><p>\begin{equation}
T((\tau&rsquo;, c&rsquo;) | (\tau, c), a) = \begin{cases}
prob(p_{\theta}(\cdot | \tau_{cond}(\tau, \tau&rsquo;, c)) = c&rsquo;), \text{where, } A(a, \tau) = \tau&rsquo; \\
0, \text{otherwise}
\end{cases}
\end{equation}</p><p>that is, the probability of a certain next state is the probability that the LM assigns to that next state given our current state via the <code>conditioning</code> prompt.</p><p>Similarly, we define an observation model using the LM&mdash;effectively, letting the LM introspect its own generation to assign a possible evaluation; this is directly analogous to the &ldquo;value&rdquo; computation step in ToT. We define the observation space to be discrete and similar to the state space, that is, \(O = C\). Importantly, however, these two spaces are <em>distinct</em>: due to the limitations of sampling, we can never observe the LM&rsquo;s evaluation of a sequence directly; hence, the claims of the LM regarding its hypothesis of state is taken as the state. We define our observation model using <code>evaluation</code>:</p><p>\begin{equation}
\omega(c&rsquo;|a,(\tau, c)) = prob(p_{\theta}(\cdot | \tau_{eval}(\tau)) = c&rsquo;)
\end{equation}</p><p>notably, \(c\), the current state, is never used.</p><p>Finally, we define our belief space as 2-simplex over \(C\) crossed with all trajectories (i.e. \(B = \triangle^{|C|} \times \tau\)). We will update our beliefs like so:</p><p>\begin{equation}
update((b_{prob}, \tau),a,o) = (DSF(b_{prob}, a,o), A(a, \tau))
\end{equation}</p><p>where \(DSF\) is the discrete state filter.</p><h3 id=decoding>Decoding</h3><p>The solution to this system will likely be approximate ((<a href=#citeproc_bib_item_5>Kurniawati, Hsu, and Lee 2008</a>)), resulting in a set of sampled alpha-vectors representing the optimal value function of this system. The process of decoding would involve seeding \(b\) with the user input (i.e. &ldquo;prompt&rdquo;) sequence, and uninformed uniform likelyhood over all three states.</p><p>Then, to perform decoding, we autoregressively preform one-step alpha-vector lookahead over our set of obtained alpha-vectors \(\Gamma\):</p><p>\begin{equation}
\pi^{\Gamma}(b) = \arg\max_{a}\qty[R(b,a)+\gamma \qty(\sum_{o}^{}P(o|b,a) U^{\Gamma}(update(b,a,o)))]
\end{equation}</p><p>where:</p><p>\begin{equation}
R(b,a) = \sum_{s}^{} R(s,a)b(s)
\end{equation}</p><p>\begin{align}
P(o|b,a) &= \sum_{s}^{} p(o|s,a) b(s) \\
&= \sum_{s}^{} \sum_{s&rsquo;}^{} T(s&rsquo;|s,a) O(o|s&rsquo;,a) b(s)
\end{align}</p><p>and</p><p>\begin{equation}
U^{\Gamma}(b) = \max_{\alpha \in \Gamma} \alpha^{\top} b
\end{equation}</p><h2 id=plan-for-evaluation>Plan for Evaluation</h2><p>ToT offers a fairly comprehensive suite of evaluations for the resulting LM agent. One task that would be salient to begin evaluation would be the crossword task, which has been shown to be difficult even with SOTA LMs like GPT-4.</p><style>.csl-entry{text-indent:-1.5em;margin-left:1.5em}</style><div class=csl-bib-body><div class=csl-entry><a id=citeproc_bib_item_1></a>Brown, Tom B., Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, et al. 2020. “Language Models Are Few-Shot Learners.” arXiv. <a href=http://arxiv.org/abs/2005.14165>http://arxiv.org/abs/2005.14165</a>.</div><div class=csl-entry><a id=citeproc_bib_item_2></a>Finlayson, Matthew, John Hewitt, Alexander Koller, Swabha Swayamdipta, and Ashish Sabharwal. 2023. “Closing the Curious Case of Neural Text Degeneration.” arXiv. <a href=http://arxiv.org/abs/2310.01693>http://arxiv.org/abs/2310.01693</a>.</div><div class=csl-entry><a id=citeproc_bib_item_3></a>Holtzman, Ari, Jan Buys, Li Du, Maxwell Forbes, and Yejin Choi. 2020. “The Curious Case of Neural Text Degeneration.” arXiv. <a href=http://arxiv.org/abs/1904.09751>http://arxiv.org/abs/1904.09751</a>.</div><div class=csl-entry><a id=citeproc_bib_item_4></a>Kaelbling, Leslie Pack, Michael L. Littman, and Anthony R. Cassandra. 1998. “Planning and Acting in Partially Observable Stochastic Domains.” <i>Artificial Intelligence</i> 101 (1): 99–134. doi:<a href=https://doi.org/10.1016/S0004-3702(98)00023-X>10.1016/S0004-3702(98)00023-X</a>.</div><div class=csl-entry><a id=citeproc_bib_item_5></a>Kurniawati, Hanna, David Hsu, and Wee Sun Lee. 2008. “SARSOP: Efficient Point-Based POMDP Planning by Approximating Optimally Reachable Belief Spaces.” In <i>Robotics: Science and Systems IV</i>, nil. doi:<a href=https://doi.org/10.15607/rss.2008.iv.009>10.15607/rss.2008.iv.009</a>.</div><div class=csl-entry><a id=citeproc_bib_item_6></a>Liu, Tianyu, Yizhe Zhang, Chris Brockett, Yi Mao, Zhifang Sui, Weizhu Chen, and Bill Dolan. 2022. “A Token-Level Reference-Free Hallucination Detection Benchmark for Free-Form Text Generation.” In <i>Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</i>, 6723–37. Dublin, Ireland: Association for Computational Linguistics. doi:<a href=https://doi.org/10.18653/v1/2022.acl-long.464>10.18653/v1/2022.acl-long.464</a>.</div><div class=csl-entry><a id=citeproc_bib_item_7></a>Verma, Siddharth, Justin Fu, Mengjiao Yang, and Sergey Levine. 2022. “CHAI: A CHatbot AI for Task-Oriented Dialogue with Offline Reinforcement Learning.” arXiv. <a href=http://arxiv.org/abs/2204.08426>http://arxiv.org/abs/2204.08426</a>.</div><div class=csl-entry><a id=citeproc_bib_item_8></a>Wei, Jason, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed H Chi, Quoc V Le, and Denny Zhou. 2022. “Chain-of-Thought Prompting Elicits Reasoning in Large Language Models.”</div><div class=csl-entry><a id=citeproc_bib_item_9></a>Yao, Shunyu, Dian Yu, Jeffrey Zhao, Izhak Shafran, Thomas L. Griffiths, Yuan Cao, and Karthik Narasimhan. 2023. “Tree of Thoughts: Deliberate Problem Solving with Large Language Models.” arXiv. <a href=http://arxiv.org/abs/2305.10601>http://arxiv.org/abs/2305.10601</a>.</div><div class=csl-entry><a id=citeproc_bib_item_10></a>Yao, Shunyu, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao. 2023. “ReAct: Synergizing Reasoning and Acting in Language Models.” arXiv. <a href=http://arxiv.org/abs/2210.03629>http://arxiv.org/abs/2210.03629</a>.</div></div></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>