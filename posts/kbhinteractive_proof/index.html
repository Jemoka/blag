<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Interactive Proof</title>
<meta name=description content="We have prover \(P\) and randomized verifier \(V\). The \(V\) asks \(P\) for membership statements, and \(P\) responds with statements. These proofs can be used to prove membership in very powerful languages.

Languages \(L\) with a \(k\) round interactive proof system, where the verifier \(V\) is poly randomized machine and its interacting with an all-powerful prover \(P\).



\(x \in L \implies \exists_{ \text{prover}}\) such that \(V\qty(x_1, \dots, y_{k})\) accepts with probability \(\geq \frac{2}{3}\)
\(x \not \in L \implies \forall _{\text{prover}}\) such that \(V\qty(x_1, \dots, y_{k})\) accepts with probability \(\leq \frac{1}{3}\)

"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Interactive Proof</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#properties-of-ip--k----kbhinteractive-proof-dot-md>Properties of <a href=HAHAHUGOSHORTCODE675s1HBHB>IP(k)</a></a><ul><li><a href=#can-we-try-to-upper-bound-the-power-of-ip--k----kbhinteractive-proof-dot-md>Can we try to upper bound the power of <a href=HAHAHUGOSHORTCODE675s2HBHB>IP(k)</a></a></li><li><a href=#ip-psace>IP = PSACE</a></li></ul></li><li><a href=#np-written-as-an-interactive-proof--kbhinteractive-proof-dot-md>NP, written as an <a href=HAHAHUGOSHORTCODE675s4HBHB>Interactive Proof</a></a><ul><li><a href=#randomized-interactive-proofs>Randomized Interactive Proofs</a></li></ul></li><li><a href=#examples>Examples</a><ul><li><a href=#graph-non-isomorphism>Graph Non-Isomorphism</a></li></ul></li></ul></nav></aside><main><article><div><p>We have prover \(P\) and <strong>randomized</strong> verifier \(V\). The \(V\) asks \(P\) for membership statements, and \(P\) responds with statements. These proofs can be used to prove membership in very powerful languages.</p><div class=definition><span><p>Languages \(L\) with a \(k\) round interactive proof system, where the verifier \(V\) is poly randomized machine and its interacting with an all-powerful prover \(P\).</p><p></span></div></p><div class=theorem><span><ul><li>\(x \in L \implies \exists_{ \text{prover}}\) such that \(V\qty(x_1, \dots, y_{k})\) accepts with probability \(\geq \frac{2}{3}\)</li><li>\(x \not \in L \implies \forall _{\text{prover}}\) such that \(V\qty(x_1, \dots, y_{k})\) accepts with probability \(\leq \frac{1}{3}\)</li></ul><p></span></div></p><div class=example><span><p>Some stuff that lives in <a href=/posts/kbhinteractive_proof/>IP(k)</a></p><ul><li>\(NP \subseteq \text{IP}[1]\), even with 1s or 0</li><li>\(\text{BPP} \subseteq IP[0]\), since \(V\) has randomized power already, we just throw away the prover</li></ul><p></span></div></p><h2 id=properties-of-ip--k----kbhinteractive-proof-dot-md>Properties of <a href=/posts/kbhinteractive_proof/>IP(k)</a></h2><h3 id=can-we-try-to-upper-bound-the-power-of-ip--k----kbhinteractive-proof-dot-md>Can we try to upper bound the power of <a href=/posts/kbhinteractive_proof/>IP(k)</a></h3><div class=theorem><span><p><a href=/posts/kbhinteractive_proof/>IP(k)</a> in &lt;ip_in_pspace></p><p></span></div></p><div class=proof><span><p>Fix \(L, x\) and a randomized poly verifier \(V\). Note that the goal of the prover \(P\), regardless of whether \(x \in L\) or not, is to maximize P[V accepts]. We want to find a bound for the system.</p><p>Consider the task of, given \(x\), compute:</p><p>\begin{equation}
\max_{\text{provers}} P[V\ \text{accept}]
\end{equation}</p><p>We can compute the expression above in EXPTIME, and in particular PSPACE, by tracing each of the computations and reuising space.</p><p></span></div></p><p>But actually, there&rsquo;s something crazier&mldr;</p><h3 id=ip-psace>IP = PSACE</h3><p>This is an extremely powreful result.</p><div class=theorem><span><p>IP = PSPACE</p><p></span></div></p><div class=proof><span><p>We have shown in \Cref{ip_in_pspace} that \(\text{IP} \subseteq \text{PSPACE}\), all that&rsquo;s left is \(\text{PSPACE} \subseteq \text{IP}\)</p><p></span></div></p><h2 id=np-written-as-an-interactive-proof--kbhinteractive-proof-dot-md>NP, written as an <a href=/posts/kbhinteractive_proof/>Interactive Proof</a></h2><div class=theorem><span><p>For a proof system whereby the prover is all powerful, and the verifier is polytime deterministic, and they get to interact with poly number of steps, then the proof system is still NP.</p><p></span></div></p><div class=proof><span><p>Because, at the initial step, the prover can entirely predict what the verifier is going to say, and just give the entire conversation at the first turn without interaction.</p><p></span></div></p><p>This is quite disappointing.</p><h3 id=randomized-interactive-proofs>Randomized Interactive Proofs</h3><p>This actually becomes interesting (namely, not NP) if you allow the verifier to be randomized! Because then the prover can&rsquo;t predict exactly what will become sent, and the prover can&rsquo;t guard against everything.</p><p>For an example of this, we go to <a href=#graph-non-isomorphism>Graph Non-Isomorphism</a>.</p><h2 id=examples>Examples</h2><h3 id=graph-non-isomorphism>Graph Non-Isomorphism</h3><p>A graph \(G\) and \(H\) are if you can rename \(G\) to get \(H\) (i.e. they are same up to renaming).</p><ul><li>GraphIsomorphism = {(G,H) | G and H are isomorphic}</li><li>GraphNonIsomorphism = {(G,H) | G and H are not isomorphic}</li></ul><p><a href=/posts/kbhgraph_isomorphism_is_in_np/>Graph Isomorphism is in NP</a>. So clearly <a href=#graph-non-isomorphism>Graph Non-Isomorphism</a> is in . But, how do we show that two things are <strong>not</strong> isomorphic? Its not known if this is in NP.</p><p>Turns out,</p><div class=theorem><span><p><a href=#graph-non-isomorphism>Graph Non-Isomorphism</a> has a simple <a href=/posts/kbhinteractive_proof/>Interactive Proof</a>!</p><p></span></div></p><div class=proof><span><p>We have graphs \(G_0, G_1\).</p><ul><li>verifier \(V\) &mdash; select a bit \(b\) at random; set \(H\) to be a random isomorphic copy of \(G_{b}\), send it to \(P\) (intuition: this should be isomorphic to isomorphic to exactly one of them, so a good \(P\) should tell us its isomorphic to one)</li><li>prover \(P\) &mdash; find \(c\) such that \(H\) and \(G_{c}\) is isomorphic, send \(c\)</li><li>verifier \(V\) &mdash; accepts if \(c = b\), otherwise, reject (because ether \(P\) is bad or our two graphs are isomorphic)</li></ul><p>Now let&rsquo;s check! Suppose \(\qty(G_0, G_1) \in \neg \text{GISO}\), that is \(G_0 \neq G_1\), then we have:</p><p>\begin{equation}
\exists_{\text{prover}} P\qty(\text{accept}) = 1
\end{equation}</p><p>by just the &ldquo;tell the truth&rdquo; prover. The more interesting case is that we want to, for \(\qty(G_0, G_1) \not \in \neg \text{GISO}\), that is \(G_0 \cong G_1\), we need:</p><p>\begin{equation}
\forall_{\text{provers}} P\qty(\text{accept}) = \frac{1}{2}
\end{equation}</p><p>&ldquo;we can&rsquo;t be fooled&rdquo;.</p><p>This is in <a href=/posts/kbhinteractive_proof/>IP(4)</a></p><p></span></div></p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>