<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Markov Decision Process</title>
<meta name=description content="A MDP is a decision network whereby a sequences of actions causes a sequence of states. Each state is dependent on the action we take and the state we are in, and each utility is dependent on action taken and the state we are in.
Note that, unlike a POMDP, we know what state we are in&mdash;the observations from the states are just unclear.
constituents \(S\): state space (assuming discrete for now, there are \(n\) states) &mdash; &ldquo;minimum set of information that allows you to solve a problem&rdquo; \(A\): action space &mdash; set of things your agent can do \(T(s&rsquo; | s,a)\): &ldquo;dynamics&rdquo;, state-transition model &ldquo;probability that we end up in \(s&rsquo;\) given \(s\) and action \(a\)&rdquo;: good idea to make a table of probabilities of source vs."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Markov Decision Process</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#constituents>constituents</a></li><li><a href=#additional-information>additional information</a><ul><li><a href=#stationary-markov-decision-process--kbhmarkov-decision-process-dot-md>stationary <a href=HAHAHUGOSHORTCODE606s10HBHB>Markov Decision Process</a></a></li><li><a href=#calculating-utility--kbhutility-theory-dot-md--with-instantaneous-rewards>calculating <a href=HAHAHUGOSHORTCODE606s13HBHB>utility</a> with instantaneous rewards</a></li><li><a href=#solving-an-mdp--kbhmarkov-decision-process-dot-md>Solving an <a href=HAHAHUGOSHORTCODE606s18HBHB>MDP</a></a></li></ul></li></ul></nav></aside><main><article><div><p>A <a href=/posts/kbhmarkov_decision_process/>MDP</a> is a <a href=/posts/kbhdecision_networks/>decision network</a> whereby a sequences of actions causes a sequence of states. Each state is dependent on the action we take and the state we are in, and each <a href=/posts/kbhutility_theory/>utility</a> is dependent on action taken and the state we are in.</p><p>Note that, unlike a <a href=/posts/kbhpartially_observable_markov_decision_process/>POMDP</a>, we know what state we are in&mdash;the observations from the states are just unclear.</p><figure><img src=/ox-hugo/2023-10-17_09-18-03_screenshot.png></figure><h2 id=constituents>constituents</h2><ul><li>\(S\): state space (assuming discrete for now, there are \(n\) states) &mdash; &ldquo;minimum set of information that allows you to solve a problem&rdquo;</li><li>\(A\): action space &mdash; set of things your agent can do</li><li>\(T(s&rsquo; | s,a)\): &ldquo;dynamics&rdquo;, state-transition model &ldquo;<a href=/posts/kbhprobability/>probability</a> that we end up in \(s&rsquo;\) given \(s\) and action \(a\)&rdquo;: good idea to make a table of probabilities of source vs. destination variables</li><li>\(R(s,a,s&rsquo;)\): expected reward given in an action and a state (real world reward maybe stochastic)</li><li>\(\pi_{t}(s_{1:t}, a_{1:t-1})\): the <a href=/posts/kbhpolicy/>policy</a>, returning an action, a system of assigning actions based on states<ul><li>however, our past states are <a href=/posts/kbhbaysian_network/#checking-for-conditional-independence>d-seperated</a> from our <a href=/posts/kbhcurrent/>current</a> action given knowing the state, so really we have \(\pi_{t}(s_{t})\)</li></ul></li></ul><h2 id=additional-information>additional information</h2><p>We assume <a href=/posts/kbhpolicy/>policy</a> to be exact right now.</p><h3 id=stationary-markov-decision-process--kbhmarkov-decision-process-dot-md>stationary <a href=/posts/kbhmarkov_decision_process/>Markov Decision Process</a></h3><p>This is a <a href=#stationary-markov-decision-process--kbhmarkov-decision-process-dot-md>stationary Markov Decision Process</a> because at each node \(S_{n}\), we have: \(P(S_{n+1} | A_n, S_n)\). Time is <strong>not</strong> a variable: as long as you know what state you are in, and what you did, you know the transition <a href=/posts/kbhprobability/>probability</a>.</p><figure><img src=/ox-hugo/2023-10-17_13-07-24_screenshot.png></figure><p>(that is, the set of states is not dependent on time)</p><h3 id=calculating-utility--kbhutility-theory-dot-md--with-instantaneous-rewards>calculating <a href=/posts/kbhutility_theory/>utility</a> with instantaneous rewards</h3><p>Because, typically, in <a href=/posts/kbhdecision_networks/>decision network</a>s you sum all the <a href=/posts/kbhutility_theory/>utilities</a> together, you&rsquo;d think that we should sum the <a href=/posts/kbhutility_theory/>utilities</a> together.</p><h4 id=finite-horizon-models>finite-horizon models</h4><p>We want to maximize reward over time, over a finite horizon \(n\). Therefore, we try to maximize:</p><p>\begin{equation}
\sum_{t=1}^{n}r_{t}
\end{equation}</p><p>this function is typically called &ldquo;<a href=/posts/kbhrandom_walk/#return--finmetrics>return</a>&rdquo;.</p><h4 id=infinite-horizon-models>infinite-horizon models</h4><p>If you lived forever, small positive \(r_{t}\) and large \(r_{t}\) makes no utility difference. We therefore add discounting:</p><p>\begin{equation}
\sum_{t=1}^{\infty} \gamma^{t-1} r_{t}
\end{equation}</p><p>where, \(\gamma \in (0,1)\)</p><p>we discount the future by some amount&mdash;an &ldquo;interest rate&rdquo;&mdash;reward now is better than reward in the future.</p><ul><li>\(\gamma \to 0\): &ldquo;myopic&rdquo; strategies, near-sighted strategies</li><li>\(\gamma \to 1\): &ldquo;non-discounting&rdquo;</li></ul><h4 id=average-return-models>average return models</h4><p>We don&rsquo;t care about this as much:</p><p>\begin{equation}
\lim_{n \to \infty} \frac{1}{n} \sum_{t=1}^{n}r_{t}
\end{equation}</p><p>but its close to <a href=#infinite-horizon-models>infinite-horizon models</a> with Gama close to \(1\)</p><h3 id=solving-an-mdp--kbhmarkov-decision-process-dot-md>Solving an <a href=/posts/kbhmarkov_decision_process/>MDP</a></h3><h4 id=you-are-handed-or-can-predict-r--s-a--and-know-all-transitions>You are handed or can predict \(R(s,a)\), and know all transitions</h4><ul><li><p>Small, Discrete State Space</p><p>Get an exact solution for \(U^{*}(s)\) (and hence \(\pi^{ *}(a, s)\)) for the problem via&mldr;</p><ul><li><a href=/posts/kbhpolicy_iteration/>policy iteration</a></li><li><a href=/posts/kbhvalue_iteration/>value iteration</a></li></ul></li></ul><ul><li><p>Large, Continuous State Space</p><ul><li><p>Parameterize Policy</p><p>Optimize \(\pi_{\theta}\) to maximize \(U(\pi_{\theta})\) using <a href=/posts/kbhpolicy_optimization/>Policy Optimization</a> methods!</p><p><strong><strong>Gradient Free</strong></strong>: lower dimension <a href=/posts/kbhpolicy/>policy</a> space</p><ul><li><a href=/posts/kbhlocal_policy_search/>Local Policy Search</a> (aka <a href=/posts/kbhlocal_policy_search/>Hooke-Jeeves Policy Search</a>)</li><li><a href=/posts/kbhgenetic_policy_search/>Genetic Policy Search</a></li><li><a href=/posts/kbhcross_entropy_method/>Cross Entropy Method</a></li></ul><p><strong><strong>Gradient Based Method</strong></strong>: higher dimension <a href=/posts/kbhpolicy/>policy</a> space</p><p><a href=/posts/kbhpolicy_gradient/>Policy Gradient</a></p></li></ul><ul><li><p>Parameterize Value Function</p><p>Optimize \(U_{\theta}(S)\) via <a href=/posts/kbhapproximate_value_function/#global-approximation>global approximation</a> or <a href=/posts/kbhapproximate_value_function/#local-approximation>local approximation</a> methods, then use a <a href=/posts/kbhaction_value_function/#value-function-policy>greedy policy</a> on that nice and optimized <a href=/posts/kbhaction_value_function/#id-0b1509e0-4d88-44d1-b6fa-fe8e86d200bb-value-function>value function</a>.</p></li></ul></li></ul><h4 id=you-can-only-reason-about-your-immediate-surroundings-local-reachable-states>You can only reason about your immediate surroundings/local reachable states</h4><p><a href=/posts/kbhonline_planning/>online planning</a></p><p>or&mldr; &ldquo;you don&rsquo;t know the model whatsoever&rdquo;</p><p><a href=/posts/kbhreinforcement_learning/>reinforcement learning</a></p><p>during these cases, you never argmax over all actions; hence, its important to remember the methods to preserve <a href=/posts/kbhexploration_and_exploitation/>Exploration and Exploitation</a>.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>