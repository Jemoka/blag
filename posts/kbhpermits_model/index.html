<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>permits model</title>
<meta name=description content="permits model is a counter for which there is \(n\) threads can do a task. For instance, there is \(n\) permits; each time it is requested, it needs to be subtracted.
Ideally, we do this without busy waiting (while loops with lock and unlocks). So:
condition variable you can call wait on a condition variable, which will block until another thread calls notify_all.
identify a single event to wait/notify ensure that there is something to check to represent the event create a condition variable and share it identify who is the notifier, call notify_all when appropriate identify who will wait, and wait until condition variable triggers condition_variable_any permitsCV; // ."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>permits model</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#condition-variable>condition variable</a><ul><li><a href=#implementation>implementation</a></li></ul></li></ul></nav></aside><main><article><div><p><a href=/posts/kbhpermits_model/>permits model</a> is a counter for which there is \(n\) threads can do a task. For instance, there is \(n\) permits; each time it is requested, it needs to be subtracted.</p><p>Ideally, we do this without busy waiting (while loops with lock and unlocks). So:</p><h2 id=condition-variable>condition variable</h2><p>you can call <strong>wait</strong> on a condition variable, which will block until another thread calls <strong>notify_all</strong>.</p><ol><li>identify a single event to wait/notify</li><li>ensure that there is something to check to represent the event</li><li>create a condition variable and share it</li><li>identify who is the notifier, call <strong>notify_all</strong> when appropriate</li><li>identify who will wait, and <strong>wait</strong> until condition variable triggers</li></ol><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>condition_variable_any</span> <span style=color:#111>permitsCV</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>thread</span><span style=color:#111>(</span><span style=color:#111>ref</span><span style=color:#111>(</span><span style=color:#111>permitsCV</span><span style=color:#111>))</span>
</span></span></code></pre></div><p>Identify the <strong>ISOLATED event</strong> to notify: for instance, whenever permit goes from 0=>1, you notify. But, when permits go from 1=>2, there really isn&rsquo;t really a need to notify. If you gave wait an unlocked lock, you UB.</p><p>But, implementing this is a little tricky: before sleeping on the condition variable, we have to release the underlying lock, but then values are not guaranteed after you unlock. So, the actual implementation:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>permits</span><span style=color:#111>.</span><span style=color:#111>lock</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>permits</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>permitsCV</span><span style=color:#111>.</span><span style=color:#111>wait</span><span style=color:#111>(</span><span style=color:#111>permitsLock</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>permits</span><span style=color:#f92672>--</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>permitsLock</span><span style=color:#111>.</span><span style=color:#111>unlock</span><span style=color:#111>();</span>
</span></span></code></pre></div><p>the condition variable will&mldr;</p><ol><li>start sleeping <strong><strong>FIRST</strong></strong></li><li>unlock a lock FOR US <strong><strong>AFTER</strong></strong> the sleeping starts</li><li>after waiting ends, tries to reaquire lock</li><li>blocks until we have the lock again</li></ol><p>this ensures that you don&rsquo;t have to give up the lock before sleeping.</p><p>We need a &ldquo;while&rdquo; loop here to CHECK whether or not, after sleeping is over, our locked variable needs to be checked again just in case another thread took it: <strong>just because we woke up it doesn&rsquo;t mean the condition is true forever</strong>.</p><p>We also need a &ldquo;while&rdquo; loop because condition variables will send <strong>false</strong> wakeup signal, so we need to check the condition to be extra sure.</p><p>so <strong><strong>CALL CONDITION VARIABLES IN A WHILE LOOP</strong></strong>.</p><h3 id=implementation>implementation</h3><p>similar to <a href=/posts/kbhmultithreading/#mutex>mutex</a>s</p><h4 id=wait>wait</h4><ol><li>should autonomically put the thread to sleep + unlock the given lock</li><li>when the thread wakes up, it should reacquire the lock + return</li></ol><h4 id=notify-one-all>notify one/all</h4><ul><li>notify_one: should wake up + unblock first waiting thread</li><li>notify_all: should wake up/unblock all waiting threads</li></ul><p>if no one is waiting, do nothing.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>