<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>programatically compiling RegEx to DFA</title>
<meta name=description content="A high level sketch:



Another High Level Sketch
Step 1: Write some RegExps
Do that.
Step 2: Construct R
For regular expressions you have defined for keywords, identifies, numbers, etc&mldr; We want to construct an uber union regular expression:
\begin{align}
R &= \text{Keyword} + \text{Identifier} + \text{Number} + \dots   \\
&= R_1 | R_2 | R_3 | \dots
\end{align}
Step 3: Tokenization
For input \(x_1, &mldr;, x_{n}\), for \(i \in 1 &mldr;n\) inclusive, we check:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>programatically compiling RegEx to DFA</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#another-high-level-sketch>Another High Level Sketch</a><ul><li><a href=#step-1-write-some-regexps>Step 1: Write some RegExps</a></li><li><a href=#step-2-construct-r>Step 2: Construct R</a></li><li><a href=#step-3-tokenization>Step 3: Tokenization</a></li></ul></li><li><a href=#how-exactly-does-matching-mean>How exactly does &ldquo;matching&rdquo; mean?</a><ul><li><a href=#algorithm-for-casting-regexp-to-nfa>algorithm for casting RegExp to NFA</a></li><li><a href=#implementing-dfas-as-a-table>implementing DFAs as a table</a></li></ul></li></ul></nav></aside><main><article><div><p>A high level sketch:</p><figure><img src=/ox-hugo/compiling_regexp.svg></figure><h2 id=another-high-level-sketch>Another High Level Sketch</h2><h3 id=step-1-write-some-regexps>Step 1: Write some RegExps</h3><p>Do that.</p><h3 id=step-2-construct-r>Step 2: Construct R</h3><p>For regular expressions you have defined for keywords, identifies, numbers, etc&mldr; We want to construct an uber union regular expression:</p><p>\begin{align}
R &= \text{Keyword} + \text{Identifier} + \text{Number} + \dots \\
&= R_1 | R_2 | R_3 | \dots
\end{align}</p><h3 id=step-3-tokenization>Step 3: Tokenization</h3><p>For input \(x_1, &mldr;, x_{n}\), for \(i \in 1 &mldr;n\) inclusive, we check:</p><p>\begin{equation}
x_1 \dots x_{i} \stackrel{?}{\in} L\qty( R)
\end{equation}</p><p>Upon success for some \(i\), we know that \(x_{1}, &mldr;, x_{i} \in L\qty(R_{j})\) for some \(j\). We can then send \(x_1, &mldr;, x_{i}\) to the parser and then continue lexing for input \(x_{i+1}&mldr;x_{n}\).</p><h4 id=ambiguity>ambiguity</h4><ul><li><strong>multiple matches, different lengths</strong>: we pick the longest possible substring</li><li><strong>multiple matches, same length</strong>: pick the first rule</li><li><strong>nothing matches</strong>: we just put a catch all rule in the bottom</li></ul><h2 id=how-exactly-does-matching-mean>How exactly does &ldquo;matching&rdquo; mean?</h2><p><a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s, <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>s, <a href=/posts/kbhnondeterministic_finite_automata/#id-4f5a240b-565b-4341-ab32-0b8b4540103f-dfa-s-are-equivalent-to-id-5520de84-0c82-4b31-97cb-51f7de4652dc-nfa-s>subset construction</a>! Conventions used in this class:</p><ul><li>\(\Sigma\) alphabet</li><li>\(S\) states</li><li>\(n\) start</li><li>\(F \subseteq S\) accepting states</li><li>\(S \to^{x} S\) transition</li></ul><p>and recall <a href=/posts/kbhregular_expression_complexity/#regular-expressions-are-equivalent-to-regular-languages>regular expressions are equivalent to regular languages</a>. When you attempt to take a transition that doesn&rsquo;t exist in NFAs, you end into nothing.</p><h3 id=algorithm-for-casting-regexp-to-nfa>algorithm for casting RegExp to NFA</h3><p>By convention every NFA will have a single starting state and a single ending state. We will then compose every composition&rsquo;s machine together.</p><h4 id=concatenation>concatenation</h4><p>For parser of \(A\) and \(B\), we compose them by composing the accept state of \(A\) with an \(\epsilon\) move to \(B\), and make \(A\) no longer an accepting state.</p><figure><img src=/ox-hugo/2025-04-10_11-29-39_screenshot.png></figure><h4 id=union>union</h4><p>We make an epsilon move from the starting state to both \(A\) and \(B\). And then when you hit the accepting state of either \(A\) or \(B\) you epsilon move to the accepting state.</p><figure><img src=/ox-hugo/2025-04-10_11-29-32_screenshot.png></figure><h4 id=kleene-star>kleene star</h4><figure><img src=/ox-hugo/2025-04-10_11-29-27_screenshot.png></figure><h3 id=implementing-dfas-as-a-table>implementing DFAs as a table</h3><ul><li>columns: alphabet</li><li>rows: states</li></ul><p>the way you implement this is to just look up the (state, symbol) pair, take the transition, and look up the new state, symbol, etc.</p><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td></tr><tr><td>b</td><td>a</td><td>b</td></tr></tbody></table><p>is</p><figure><img src=/ox-hugo/2025-04-10_11-47-48_screenshot.png></figure><p>and so on. To construct this table, you just read off the transition function.</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>