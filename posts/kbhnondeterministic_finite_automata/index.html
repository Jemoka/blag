<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Non-deterministic Finite Automata</title>
<meta name=description content="NFA is a relaxation of DFA, but which is allowed to make non-deterministic &ldquo;verified guesses&rdquo;.
this is basically a DFA, but our new machine accepts a string if there exists some path that reaches some accept state from some start state.
at each state, we can have any number of out arrows for some letter \(\sigma \in \Sigma\), including for the empty string \(\varepsilon\). meaning we can move between states without doing anything."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Non-deterministic Finite Automata</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#constituents>constituents</a></li><li><a href=#requirements>requirements</a><ul><li><a href=#accept>accept</a></li></ul></li><li><a href=#additional-information>additional information</a><ul><li><a href=#nfas-are-usually-simpler-than-dfas>NFAs are usually simpler than DFAs</a></li><li><a href=#non-deterministic-computation>Non-deterministic Computation</a></li><li><a href=#dfa--kbhdeterministic-finite-automata-dot-md--s-are-equivalent-to-nfa--kbhnondeterministic-finite-automata-dot-md--s><a href=HAHAHUGOSHORTCODE810s5HBHB>DFA</a>s are equivalent to <a href=HAHAHUGOSHORTCODE810s6HBHB>NFA</a>s</a></li></ul></li><li><a href=#nfa--kbhnondeterministic-finite-automata-dot-md--also-recognizes-exactly-regular-languages><a href=HAHAHUGOSHORTCODE810s17HBHB>NFA</a> also recognizes exactly regular languages</a></li></ul></nav></aside><main><article><div><p><a href=/posts/kbhnondeterministic_finite_automata/>NFA</a> is a relaxation of <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>, but which is allowed to make non-deterministic &ldquo;verified guesses&rdquo;.</p><p>this is basically a <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>, but our new machine accepts a string if there exists <em>some path</em> that reaches <em>some accept state</em> from <em>some start state</em>.</p><p>at each state, we can have any number of out arrows for some letter \(\sigma \in \Sigma\), <strong>including</strong> for the empty string \(\varepsilon\). meaning we can move between states without doing anything.</p><p>we (Omer) allows <strong>multiple <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a> start states</strong> (Spiser only allows one). we can convert between these easily just by having an epsilon (empty string) transition stuck between the &ldquo;single&rdquo; start state and the multiple start states.</p><h2 id=constituents>constituents</h2><p>A NFA is a five-tuple \(N = (Q, \Sigma, \delta, Q_{0}, F)\), whereby:</p><ul><li>\(Q\) is the finite set of all states</li><li>\(\Sigma\) is the <a href=/posts/kbhalphabet/>alphabet</a></li><li>\(\delta: Q \times \Sigma_{\varepsilon} \to 2^{Q}\) (where \(\Sigma_{\varepsilon} = (\Sigma \cup \{\varepsilon\})\), with \(\varepsilon\) being the empty string); the output is a boolean assignment of whether or not we can reach each state, because note you are now allowed multiple edges between states</li><li>\(Q_0 \subseteq Q\) which is the set of start states</li><li>\(F \subseteq Q\) remains the set of accept states</li></ul><h2 id=requirements>requirements</h2><h3 id=accept>accept</h3><p>Let \(w_1, &mldr;, w_{n} \in \Sigma\), and \(w = w_1 &mldr; w_{n} \in \Sigma^{*}\), \(M\) <strong>accepts</strong> \(w\) if there exists \(r_0, &mldr;, r_{n} \in Q\) such that:</p><ul><li>\(r_{0} \in Q_{0}\)</li><li>\(r_{i+1} \in \delta(r_{i}, w_{i+1})\) for all \(i=0, &mldr;, n-{1}\), and</li><li>\(r_{n} \in F\)</li></ul><h2 id=additional-information>additional information</h2><h3 id=nfas-are-usually-simpler-than-dfas>NFAs are usually simpler than DFAs</h3><p>&mldr;because you don&rsquo;t have to specify all edges; non-specified transitions means the can be automatically rejected</p><h3 id=non-deterministic-computation>Non-deterministic Computation</h3><p>while deterministic computation simply asks whether a sequence of computation can be accepted or rejected, nondeterministic computations asks whether or not there exists a path to an acceptance</p><h3 id=dfa--kbhdeterministic-finite-automata-dot-md--s-are-equivalent-to-nfa--kbhnondeterministic-finite-automata-dot-md--s><a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s are equivalent to <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>s</h3><p>we want to show that <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s recognize the same set of languages as <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>s. in other words, <a href=#non-deterministic-computation>non-determinism</a> does not add power for finite automata&mldr; &ldquo;finite memory is very robust&rdquo;.</p><hr><p>we want to define the <a href=#dfa--kbhdeterministic-finite-automata-dot-md--s-are-equivalent-to-nfa--kbhnondeterministic-finite-automata-dot-md--s>subset construction</a>; tho goal here is that given a particular <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a> named \(N\), we desire to find a particular <a href=/posts/kbhdeterministic_finite_automata/>DFA</a> named \(M\) which recognizes the same <a href=/posts/kbhalphabet/>language</a>.</p><p>insight: <a href=/posts/kbhdeterministic_finite_automata/>DFA</a> and <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>s are markovian! instead of monitoring all the different paths you take, we only monitor all the possible states you could have reached&mdash;this is, then, only exponential in the number of states.</p><p>we therefore do computation in parallel on the set of all possible states that could be reached thus far. at each step, then, a <a href=/posts/kbhdeterministic_finite_automata/>DFA</a> you defined from an <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a> has a state space of \(Q&rsquo; = 2^{Q}\). Each of your states, then, is some subset of possible states in the original <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>.</p><hr><h4 id=epsilon-closure>epsilon closure</h4><p>to deal with epsilon steps (i.e. steps where you do nothing and advance), you have to first define the <a href=#dfa--kbhdeterministic-finite-automata-dot-md--s-are-equivalent-to-nfa--kbhnondeterministic-finite-automata-dot-md--s>epsilon closure</a>:</p><p>for a subset of states \(S \subseteq Q\), the \(\varepsilon\) closure of \(S\) is:</p><p>\begin{equation}
\varepsilon (S) = \qty {q | q\ \text{reachable from some}\ s \in S\ \text{by taking one or more $\varepsilon$ transitions}}
\end{equation}</p><p>and now, onto the construction that <a href=#dfa--kbhdeterministic-finite-automata-dot-md--s-are-equivalent-to-nfa--kbhnondeterministic-finite-automata-dot-md--s>DFAs are equivalent to NFAs</a></p><h4 id=proof>proof</h4><ul><li>\(Q&rsquo;=2^{Q}\)</li><li>\(\delta&rsquo;: Q&rsquo; \times \Sigma \to Q&rsquo;\), specifically \(\bigcup \varepsilon \qty(\delta\qty(r, \sigma)), r\in R\), where \(R \in Q&rsquo;\) is one of our conjoined-states<ul><li>that is, we apply every transition we can on the states that we have, and union all of their results together</li></ul></li><li>\(F&rsquo; = \qty {R \in Q&rsquo; | f \in R\ \text{for some}\ f \in F}\), that is, the subset of the conjoined states for which there is a single member in the conjoined state that&rsquo;s active that is also an accept state</li><li>\(q_0&rsquo; = \varepsilon (q_0)\)</li></ul><h2 id=nfa--kbhnondeterministic-finite-automata-dot-md--also-recognizes-exactly-regular-languages><a href=/posts/kbhnondeterministic_finite_automata/>NFA</a> also recognizes exactly regular languages</h2><p>that is, <a href=/posts/kbhdeterministic_finite_automata/>DFA</a> and <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a> recognizes the same types of languages</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>