<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>virtual memory</title>
<meta name=description content="We are trying to share a resource: memory; memory allows multiple processes to use a share pool of memory.
key goals multitasking: multiple processes should be able to use memory transparency: no process need to know that memory is shared; each process should be able to run regardless of the number/locations of processes isolation: processes shouldn&rsquo;t be able to corrupt other processes&rsquo; memory efficiency: shouldn&rsquo;t be degraded by sharing virtual memory The operating system will translate virtual addresses (which are 0 based for every program, which isn&rsquo;t a problem) to physical addresses in memory."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>virtual memory</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#key-goals>key goals</a></li><li><a href=#virtual-memory>virtual memory</a></li><li><a href=#dynamic-address-translation>dynamic address translation</a><ul><li><a href=#base-and-bound>base and bound</a></li></ul></li><li><a href=#why-not-something-simpler>why not something simpler?</a><ul><li><a href=#single-tasking-memory>single-tasking memory</a></li><li><a href=#load-time-relocation>load-time relocation</a></li></ul></li></ul></nav></aside><main><article><div><p>We are trying to share a resource: memory; memory allows multiple processes to use a share pool of memory.</p><h2 id=key-goals>key goals</h2><ul><li><strong>multitasking</strong>: multiple processes should be able to use memory</li><li><strong>transparency</strong>: no process need to know that memory is shared; each process should be able to run regardless of the number/locations of processes</li><li><strong>isolation</strong>: processes shouldn&rsquo;t be able to corrupt other processes&rsquo; memory</li><li><strong>efficiency</strong>: shouldn&rsquo;t be degraded by sharing</li></ul><h2 id=virtual-memory>virtual memory</h2><p>The operating system will translate <strong>virtual</strong> addresses (which are 0 based for every program, which isn&rsquo;t a problem) to <strong>physical</strong> addresses in memory.</p><ul><li>the OS doesn&rsquo;t need to map all virtual addresses unless its needed (i.e. if the program is asking for it)</li><li>worst case: we can kick out unused memory into disk, and load it back when needed</li></ul><p>This is an example of <a href=/posts/kbhvirtual_memory/>virtualization</a>.</p><h2 id=dynamic-address-translation>dynamic address translation</h2><p>The system will die if we try to do virtual mapping to physical mapping.</p><p>So we have a <a href=#dynamic-address-translation>Memory Management Unit</a> (<a href=#dynamic-address-translation>MMU</a>) to do:</p><p>How does an <a href=#dynamic-address-translation>MMU</a> work?</p><h3 id=base-and-bound>base and bound</h3><p>This is basically <a href=#load-time-relocation>load-time relocation</a>, but with <a href=/posts/kbhvirtual_memory/>virtual memory</a>.</p><ul><li>assign a location in physical memory, call the <strong>base</strong>; during translation, we just add every virtual address by the <strong>base</strong></li><li>we can cap the virtual address space for each process by a <strong>bound</strong>, we can raise a bus error/segfault if it goes above the highest allowable</li></ul><p>The <strong>bound</strong> is a virtual address (the first invalid address in the virtual world), whereas the <strong>base</strong> is a physical address. This is both stored in the <strong>process control block</strong>.</p><h4 id=translation>translation</h4><ul><li>compare virtual address to bound, <a href=/posts/kbhdispatching/#trap>trap</a> and raise if >= <strong>bound</strong></li><li>then, return virtual address + <strong>base</strong></li></ul><p>importantly, we can arbitrary adjust base and bound.</p><h4 id=tradeoff>tradeoff</h4><ul><li><p>good news</p><ul><li><strong>inexpensive</strong>: just doing addition</li><li><strong>doesn&rsquo;t require additional space</strong>: (just two addresses)</li><li><strong>separation</strong>: <a href=/posts/kbhvirtual_memory/>virtualization</a>.</li></ul></li></ul><ul><li><p>bad news</p><ul><li><strong>one contiguous region</strong>: need to allocate free spcae</li><li><strong>fragmentation</strong>: because of the above</li><li><strong>growing can only happens upwards with bounds</strong> (and its kind of useless)&mdash;we can&rsquo;t move the stack up in virtual space</li><li>no read only memory (we&rsquo;ll want to limit access to code segment)</li></ul></li></ul><h2 id=why-not-something-simpler>why not something simpler?</h2><h3 id=single-tasking-memory>single-tasking memory</h3><p>very bad idea:</p><p>ASSUME that there is only one process. Stack grows down, data grows up, and code sits at the bottom.</p><h4 id=tradeoff>tradeoff</h4><ul><li><strong>no isolation</strong>: even in this case, nothing is stopping the program from accessing memory in the OS reserve segment; which is bad.</li><li><strong>no multitasking</strong>: because, well, we have one program</li></ul><h3 id=load-time-relocation>load-time relocation</h3><p>separate processes.</p><p>When program is compiled, it assumes that its initial address is <code>0x0</code>; so, at load time, we have to go into the code segment when the program is set up and increment all of its memory addresses up.</p><h4 id=tradeoff>tradeoff</h4><ul><li><strong>no isolation</strong>: nothing is stopping the program from accessing memory in otherbody&rsquo;s segments</li><li>must decide the memory usage of a program ahead of time + cannot grow if needs more memory (we can&rsquo;t move because the addresses would be in stack)</li><li>external fragmentation (normal alloc problems)</li></ul></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>