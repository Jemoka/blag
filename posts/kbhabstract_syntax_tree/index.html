<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>abstract syntax tree</title>
<meta name=description content="abstract syntax tree is what happens when CFGs is applied to text (i.e., the parser traces the AST in time).
Building an AST
Generally, each production will have an action, which is the relevant computation.
X -> Y1... Yn { action }
Each symbol X admits an attribute X.val

for each terminal, val is the associated lexeme
for non-terminals, val is the expression&rsquo;s value (i.e., from the values of the subexpressions)

you job is to compose the subexpressions&rsquo; values and stick it into X.val. Notably, cycles are not allowed because we typically parse bottom-up, left ot right."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>abstract syntax tree</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#building-an-ast>Building an AST</a><ul><li><a href=#actually-doing-it>actually doing it</a></li><li><a href=#s-attribute>s-attribute</a></li><li><a href=#declarative-vs-imperative-style>declarative vs imperative style</a></li><li><a href=#an-example>an example</a></li></ul></li><li><a href=#example>example</a></li></ul></nav></aside><main><article><div><p><a href=/posts/kbhabstract_syntax_tree/>abstract syntax tree</a> is what happens when <a href=/posts/kbhcontext_free_grammars/>CFG</a>s is applied to text (i.e., the parser traces the AST in time).</p><h2 id=building-an-ast>Building an AST</h2><p>Generally, each production will have an <em>action</em>, which is the relevant computation.</p><pre tabindex=0><code class=language-bison data-lang=bison>X -&gt; Y1... Yn { action }
</code></pre><p>Each symbol <code>X</code> admits an attribute <code>X.val</code></p><ul><li>for each terminal, <code>val</code> is the associated lexeme</li><li>for non-terminals, <code>val</code> is the expression&rsquo;s value (i.e., from the values of the subexpressions)</li></ul><p>you job is to compose the subexpressions&rsquo; values and stick it into <code>X.val</code>. Notably, cycles are not allowed because we typically parse bottom-up, left ot right.</p><h3 id=actually-doing-it>actually doing it</h3><p>For instance, consider:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>E</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>int</span> <span style=color:#111>{</span> <span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>ast</span> <span style=color:#f92672>=</span> <span style=color:#111>mkleaf</span><span style=color:#111>(</span><span style=color:#111>int</span><span style=color:#f92672>.</span><span style=color:#111>lexval</span><span style=color:#111>)</span> <span style=color:#111>}</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#00a8c8>E1</span> <span style=color:#f92672>+</span> <span style=color:#00a8c8>E2</span> <span style=color:#111>{</span> <span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>ast</span> <span style=color:#f92672>=</span> <span style=color:#111>mkplus</span><span style=color:#111>(</span><span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>ast</span><span style=color:#111>,</span> <span style=color:#00a8c8>E2</span><span style=color:#f92672>.</span><span style=color:#111>ast</span><span style=color:#111>)</span> <span style=color:#111>}</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>ast</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>E1</span><span style=color:#f92672>.</span><span style=color:#111>ast</span>
</span></span></code></pre></div><h3 id=s-attribute>s-attribute</h3><p>&mldr;or synthesized attributes, are calculated from attributes of descendent in the parse tree. For instance, <code>E.val</code> is a synthesized attribute</p><p><a href=#s-attribute>inherited-attribute</a>, which is rarer, is attributes parsed from teh parent.</p><h3 id=declarative-vs-imperative-style>declarative vs imperative style</h3><p>Two parsing ordering styles&mldr;</p><h4 id=declarative-style>Declarative style</h4><ul><li>resolution is not specified</li><li>parser figures it out</li></ul><h4 id=imperative-style>Imperative style</h4><ul><li>evalution is fixed</li><li>suppose action manipulates global state</li></ul><h3 id=an-example>an example</h3><p>Consider the grammar</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>E</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Int</span> <span style=color:#f92672>|</span> <span style=color:#00a8c8>E</span> <span style=color:#f92672>+</span> <span style=color:#00a8c8>E</span> <span style=color:#f92672>|</span> <span style=color:#111>(</span><span style=color:#00a8c8>E</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>For instance:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>E</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>int</span> <span style=color:#111>{</span> <span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>val</span> <span style=color:#f92672>=</span> <span style=color:#111>int</span><span style=color:#f92672>.</span><span style=color:#111>val</span> <span style=color:#111>}</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#00a8c8>E1</span> <span style=color:#f92672>+</span> <span style=color:#00a8c8>E2</span> <span style=color:#111>{</span> <span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>val</span>  <span style=color:#f92672>=</span> <span style=color:#00a8c8>E1</span><span style=color:#f92672>.</span><span style=color:#111>val</span> <span style=color:#f92672>+</span> <span style=color:#00a8c8>E2</span><span style=color:#f92672>.</span><span style=color:#111>val</span> <span style=color:#111>}</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#111>(</span> <span style=color:#00a8c8>E1</span> <span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>{</span> <span style=color:#00a8c8>E</span><span style=color:#f92672>.</span><span style=color:#111>val</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>E1</span><span style=color:#f92672>.</span><span style=color:#111>val</span> <span style=color:#111>}</span>
</span></span></code></pre></div><h2 id=example>example</h2><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>E</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>int</span> <span style=color:#f92672>|</span> <span style=color:#111>(</span><span style=color:#00a8c8>E</span><span style=color:#111>)</span> <span style=color:#f92672>|</span> <span style=color:#00a8c8>E</span> <span style=color:#f92672>+</span> <span style=color:#00a8c8>E</span>
</span></span></code></pre></div><p>and the string</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#ae81ff>5</span> <span style=color:#f92672>+</span> <span style=color:#111>(</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>We would draw a tree</p><figure><img src=/ox-hugo/2025-04-17_11-03-19_screenshot.png></figure><p>and crunch that into a data structure (where exprs can point to other structures.)</p><figure><img src=/ox-hugo/2025-04-17_11-05-54_screenshot.png></figure></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>