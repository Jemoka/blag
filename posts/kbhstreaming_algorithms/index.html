<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Streaming Algorithm</title>
<meta name=description content="Streaming Algorithms are computation that grow with the size of the input at a &ldquo;small&rdquo;(?) rate. The memory of these systems is not large&mdash;they grow roughly logarithmically or poly-logorithmically against the size of the system.
Every so often as we process our system, we have to output a symbol that tells us about the stream we saw so far.
streaming vs FA
Streaming Algorithms is a superset of DFAs: things that Streaming Algorithms can&rsquo;t do can&rsquo;t also be done with DFAs. Their memory doesn&rsquo;t grow too large against the sizes of strings."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Streaming Algorithm</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#streaming-vs-fa>streaming vs FA</a></li><li><a href=#communication--kbhsu-engr76-may072024-dot-md><a href=HAHAHUGOSHORTCODE1259s5HBHB>communication</a></a></li><li><a href=#examples>examples</a><ul><li><a href=#ones-vs-zeros>ones vs zeros</a></li><li><a href=#frequent-items>frequent items</a></li><li><a href=#number-of-distinct-elements>number of distinct elements</a></li><li><a href=#number-of-distinct-elements>number of distinct elements</a></li><li><a href=#streaming-vs-dfa>streaming vs DFA</a></li></ul></li></ul></nav></aside><main><article><div><p><a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a> are computation that grow with the size of the input at a &ldquo;small&rdquo;(?) rate. The memory of these systems is not large&mdash;they grow roughly logarithmically or poly-logorithmically against the size of the system.</p><p>Every so often as we process our system, we have to output a symbol that tells us about the stream we saw so far.</p><h2 id=streaming-vs-fa>streaming vs FA</h2><p><a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a> is a superset of <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s: things that <a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a> can&rsquo;t do can&rsquo;t also be done with <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s. Their memory doesn&rsquo;t grow too large against the sizes of strings.</p><h2 id=communication--kbhsu-engr76-may072024-dot-md><a href=/posts/kbhsu_engr76_may072024/#communication>communication</a></h2><p>we lastly consider <a href=/posts/kbhsu_engr76_may072024/#communication>communication</a>, as a limited-resource thing that <a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a> can solve. we also consider impossibility results from <a href=/posts/kbhsu_engr76_may072024/#communication>communication</a> to give us impossibilities with <a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a>.</p><h2 id=examples>examples</h2><h3 id=ones-vs-zeros>ones vs zeros</h3><p>a streaming algorithm to measure if a <a href=/posts/kbhalphabet/>language</a> has more \(1\) than \(0\).</p><p>\begin{equation}
L = \qty {x \mid x\text{ has more 1s than 0s}}
\end{equation}</p><p>we can do this by tracking \(B\) a majority bit (currently what&rsquo;s winning), and \(C\) how many more times that we saw \(B\) than \(\neg B\).</p><p>(we do this instead of two counters because storage efficiency).</p><p>Note that for strings of length \(n\), you need at most \((1+\log_{2}n)\) bits of space to store counters \(b\) (which just flips) and \(c\) (because the counter would basically need to store, at most, the entire string in terms of all ones into the counter, which is \(\log n\).)</p><h4 id=memory-complexity-of-ones-vs-zeros>memory complexity of ones vs zeros</h4><p>every streaming algorithm for \(L\) (above) needs \((\log_{2}n)-1\) bits of space.</p><p>WLO(most)G let \(n\) be oven, and \(L_{n} = \qty {0,1}^{n} \cap L\). We will show a set \(S_{n}\) such that each pair in \(S_{n}\) is distinguishable in \(L_{n}\) with length \(\frac{n}{2}+1\). Meaning for this language to be regular it has to have that many equivalence classes&mdash;and in particular every streaming algorithm on \(L\) needs at least \((\log n) - 1\) bits of memory.</p><hr><p>Let \(S_{n} = \qty {0^{\frac{n}{2} -i} 1^{i} \mid i = 0, \dots, \frac{n}{2}}\).</p><p>Select two strings from \(S\), we see that \(x=0^{\frac{n}{2}-k}1^{k}\) and \(y = 0^{\frac{n}{2}-j}1^{j}\) be from \(S_{n}\), with \(k > j\). The distinguishing string here is \(z = 0^{k-1}1^{\frac{n}{2}-(k-1)}\) (through noticing the fact that \(k>j\)). Therefore, \(x\) and \(y\) are in different equivalence classes.</p><p>Hence, at least \(| S_{n}|\)</p><h3 id=frequent-items>frequent items</h3><p>given a count \(k\) and a string \(x = x_1 &mldr; x_{n} \in \Sigma^{n}\), we want the set \(S = \qty {\sigma \in \Sigma \mid \sigma \text{ occurs } > \frac{n}{k}\text{ times in } x}\).</p><p>We will be able to do this in a streaming algorithm in \(O \qty(k \qty(\log |\Sigma| + \log n))\) space (this is actually quite cool, because we somehow are about to not keep track of every symbol, instead just tracking \(\log (\Sigma)\) of them instead.</p><hr><ul><li>Initialize a set \(T \subseteq \Sigma \times \mathbb{N}\). It contains a symbol and a counter.</li></ul><p>-theorem Read a symbol \(\sigma\)</p><ul><li>if \((\sigma, m) \in T\), then increment: \((\sigma, m) \to (\sigma, m+1)\) (remove and add)</li><li>else, if \(|T| &lt; k-1\), then \(T = T+ \qty {(\sigma, 1)}\)</li><li>else, for all \((\sigma&rsquo;, m&rsquo;) \in T\), we decrement them all<ul><li>\((\sigma&rsquo;, m&rsquo;) \to (\sigma&rsquo;, m&rsquo;-1)\)</li><li>if \(m&rsquo; = 0\), then we remove the pair \((\sigma&rsquo;, m&rsquo;)\) from \(T\)</li></ul></li></ul><p>notice that since each increase round increase results in \(1\) counters, but each decrease round decreases results in \(k\) counters. This means that there is at most \(\frac{n}{k}\) decrease rounds (because each round decreases \(k\) counters, by the \(k\) th decreasing round you have decreased all \(n\) of your counters.)</p><p>So, for a given symbol, it will stay in the list if its count is non-zero, meaning its occurrence count should be at least \(\frac{n}{k}\) (otherwise it won&rsquo;t stay in the list).</p><p>Finally, in a second pass, we solve this actual problem by counting all symbols in $T$&mdash;allowing us to have bounded memory. At the end, we tally and filter the counts as needed to output the symbols that output \(\frac{n}{k}\) times.</p><h3 id=number-of-distinct-elements>number of distinct elements</h3><p>We have a stream of elements \(x \in \qty {0,1, \dots 2^{k}}^{*}\), and in particular \(2^{k} > |x|^{2}\). We want to know the number of distinct elements appearing in $x$&mdash;call that DE. There&rsquo;s a trivial solution is in \(O(kn)\) space (we can just remember the string, where each number is encoded in \(k\) bits).</p><hr><p>Theorem: we can&rsquo;t do much better than that; the actual space requirement is $Î©(kn)$&mdash;\(kn\) up to a constant.</p><p>Let us define \(x,y \in \Sigma^{*}\) as DE <em>distinguishable</em> if there are some string \(z \in \Sigma^{ *}\) such that \(xz\) and \(yz\) contain different numbers of distinct elements.</p><p>So, let \(S \in \Sigma^{*}\) be such that every pair in \(S\) is DE-distinguishable; then, every streaming algorithm in DE needs \(\geq \qty(\log_{2}|S|)\) bits of space (because we basically need to store which of those equivalence classes we have as an ID. (proof: pigeonhole, if we don&rsquo;t have enough space, we have two distinguishable strings for which our streaming algorithm will not be able to tell the difference).</p><p>For subset of symbols \(T \subseteq \Sigma\) of size \(\frac{n}{2}\); we define \(x_{T}\) to be any concatenation of strings in \(T\). We can create this set \(S\) filled with such \(x_{T}\) following the following rules:</p><ol><li>we claim that for \(T\) and \(T&rsquo;\) being distinct (not necessarily disjoint), \(x_{T}\) and \(x_{T&rsquo;}\) is distinguishable.</li><li>Notice: \(x_{T}x_{T}\) contains \(\frac{n}{2}\) distinct elements, yet \(x_{T&rsquo;}x_{T}\) contains more than \(\frac{n}{2}\) distinct elements.</li></ol><p>There are \(2^{\Omega(kn)}\) such distinct subsets as long as where \(2^{k} > n^{2}\).</p><h3 id=number-of-distinct-elements>number of distinct elements</h3><p>Let&rsquo;s now rephrase the number of distinct elements problem, but now into a randomized streaming algorithm.</p><p>There&rsquo;s a randomized streaming algorithm which approximates true DE up to \(0.1\%\) error, using \(O(k+\log n)\) space.</p><p>Assuming the choice of strings in the vocabulary is uniform, by keeping track of the minimial element, we can infer the size of the vocabulary (because we think the minimal element times the number of samples is the total amount of symbols assuming uniform distribution).</p><p>Even if we didn&rsquo;t have a uniform distribution of symbols, we can force one by applying a random permutation \(h\) over \(\qty{0,1, &mldr;, 2^{k}}\) and for each character we just randomly map it somewhere using it in the permutation. Thereby, as long as we draw the random names uniformly, we essentially are able to use the same minimal sampling trick from above.</p><p>To get a good estimate, we then choose a few of those \(h\) and run the algorithm.</p><h3 id=streaming-vs-dfa>streaming vs DFA</h3><ol><li>streaming algorithms can output more than one bit</li><li>and the memory or space of a streaming algorithm can slowly increase => and in particular it can recognize some irregular languages</li><li>you could sometimes allow multiple passes over the data</li></ol><h4 id=a-dfa-is-a-streaming-algorithm>a DFA is a streaming algorithm</h4><p>Suppose \(L\) can be recognized by a DFA \(M\) with \(\leq 2^{p}\) states. Then, \(L\) is computable by a streaming algorithm \(A\) using \(\leq p\) bits of space.</p><p>We do this by literally tracking what state we are at using our \(p\) bits of space; we binarize the state ID, and then just apply the transition function and update the stored state ID.</p><ul><li><strong>initialize</strong>: encode start state of \(M\) in memory</li><li><strong>each symbol</strong>: use transition function, update \(M\) in memory</li><li><strong>on end</strong>: output accept if current state \(M\) is a final state, reject otherwise</li></ul><h4 id=a-streaming-algorithm-can-be-a-dfa-given-bounded-length>a streaming algorithm can be a DFA given bounded length</h4><p>Suppose \(L \in \Sigma^{*}\); let us define a \(L_{n} = \qty {x \in L \mid |x | = n}\) and \(L_{\leq n} = \qty {x \in L \mid |x| \leq n}\).</p><p>Suppose \(L\) is computable by a streaming algorithm \(A\) using \(f(n)\) bits of space for all strings up to \(n\), then there exists for all \(n\) a particular DFA with \(\leq 2^{n}\) states such that \(L_{\leq n} = L(M)_{\leq n}\).</p><p>Note that since \(A\) has \(n\) bits of memory, there is at most \(2^{n}\) configurations of \(A\)&rsquo;s memory. The transition function, therefore, simply has to mimic how \(A\) updates its memory.</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>