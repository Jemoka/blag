<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>turing machine (overview)</title>
<meta name=description content="turing machine is a computational system that has a memory tape, and can go through the input multiple times; they don&rsquo;t have to accept or reject states, turing machines can run forever and can have loops.
For the main topic, see turing machine
decidable vs. recognizable languages

there are not enough Turing Machines to compute every language (so there are non-recognizable/non-decidable languages)
halting problem and ATM, meaning strings where Turing Machines can&rsquo;t decide them

&ldquo;the diagonalization argument&rdquo;
mapping reduction
Rice&rsquo;s Theorem
strong reduction: higher achy of hard problems



self-reference

turing Machines can view and produce its own code.
foundations of mathematics can be shown using these systems

Kolomogorov Complexity
see Kolomogorov Complexity"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>turing machine (overview)</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#decidable-vs-dot-recognizable-languages>decidable vs. recognizable languages</a></li><li><a href=#self-reference>self-reference</a></li><li><a href=#kolomogorov-complexity--kbhkolomogorov-complexity-dot-md><a href=HAHAHUGOSHORTCODE1480s4HBHB>Kolomogorov Complexity</a></a></li><li><a href=#non-deterministic-turing-machine>Non-deterministic Turing Machine</a></li><li><a href=#encodeable-turing-machines>Encodeable Turing Machines</a></li></ul></nav></aside><main><article><div><p>turing machine is a computational system that has a memory tape, and can go through the input multiple times; they don&rsquo;t have to accept or reject states, turing machines can run forever and can have loops.</p><p>For the main topic, see <a href=/posts/kbhturing_machinea/>turing machine</a></p><h2 id=decidable-vs-dot-recognizable-languages>decidable vs. recognizable languages</h2><ul><li>there are not enough Turing Machines to compute every language (so there are non-recognizable/non-decidable languages)</li><li>halting problem and ATM, meaning strings where Turing Machines can&rsquo;t decide them<ul><li>&ldquo;the <a href=/posts/kbhdiagonalization_argument/>diagonalization argument</a>&rdquo;</li><li><a href=/posts/kbhmapping_reduction/>mapping reduction</a></li><li><a href=/posts/kbhrice_s_theorem/>Rice&rsquo;s Theorem</a></li><li>strong reduction: higher achy of hard problems</li></ul></li></ul><h2 id=self-reference>self-reference</h2><ul><li>turing Machines can view and produce its own code.</li><li>foundations of mathematics can be shown using these systems</li></ul><h2 id=kolomogorov-complexity--kbhkolomogorov-complexity-dot-md><a href=/posts/kbhkolomogorov_complexity/>Kolomogorov Complexity</a></h2><p>see <a href=/posts/kbhkolomogorov_complexity/>Kolomogorov Complexity</a></p><h2 id=non-deterministic-turing-machine>Non-deterministic Turing Machine</h2><p>They are not really good computational system, non-determinism doesn&rsquo;t add that much power by normal Turing Machine.</p><h2 id=encodeable-turing-machines>Encodeable Turing Machines</h2><p>For every Turing Machine, we can encode it into a <a href=/posts/kbhalphabet/>string</a>. We can, for instance, use a turing machine to generate another turing machine.</p><p>This also allows us to make <a href=/posts/kbhuniversal_turing_machine/>universal turing machine</a>s&mdash;using Turing machines to simulate anotherr turing machines.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>