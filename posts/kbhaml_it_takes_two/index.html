<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>AML: It Takes Two</title><meta name=description content="Hello everyone! It&rsquo;s April, which means we are ready again for a new unit. Let&rsquo;s dive in.
You know what&rsquo;s better than one neural network? TWO!!! Multi-modal approaches&mdash;making two neural networks interact for a certain result&mdash;dominate many of the current edge of neural network research. In this unit, we are going to introduce one such approach, Generative Adversarial Networks (GAN), but leave you with some food for thought for other possibilities for what training multiple networks together can do."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://twitter.com/jemokajack class=header-social id=header-twitter><i class="ic fa-brands fa-twitter"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>AML: It Takes Two</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#better--motivation>(Better) Motivation</a></li><li><a href=#gans>GANs</a><ul><li><a href=#discriminator-d--x>Discriminator \(D(x)\)</a></li><li><a href=#generator-g--x>Generator \(G(x)\)</a></li><li><a href=#loss-functions>Loss Functions</a></li></ul></li><li><a href=#the-training-loop>The Training Loop</a></li></ul></nav></aside><main><article><div><p>Hello everyone! It&rsquo;s April, which means we are ready again for a new unit. Let&rsquo;s dive in.</p><p>You know what&rsquo;s better than one neural network? TWO!!! Multi-modal approaches&mdash;making two neural networks interact for a certain result&mdash;dominate many of the current edge of neural network research. In this unit, we are going to introduce one such approach, <strong>Generative Adversarial Networks</strong> (<strong>GAN</strong>), but leave you with some food for thought for other possibilities for what training multiple networks together can do.</p><p>Be aware that this unit will begin our more theory-focused discussions, and will leave more of the implementation up to your own explorations or a later fuller example. If you don&rsquo;t understand the math or the theory, please do flag us down in class or out to get things clarified.</p><h2 id=motivation>Motivation</h2><p>Although we will provide motivations for the architecture of a <strong>GAN</strong> in a bit, let&rsquo;s first provide a problem to ground ourselves.</p><p>Say we want to build a neural network to generate pictures of mountain goats. How would you do that?</p><p>You can&rsquo;t build a supervised model exactly: what&rsquo;s the input, and what are the labels? No clear answer. Even if you have labels, you&rsquo;d have infinitely many possible such mountain goats; how do you generate labels for all of those?</p><p>To help us in solving this problem, let us make a few related claims that may seem unmotivated for now:</p><ol><li>It is easy to find images of mountain goats <code>[citation needed]</code></li><li>It is eas(ier) to train a model to classify if an image is a mountain goat or not</li><li>It is easy to generate random noise</li><li>We want more pictures of mountain goats because they are cool</li></ol><p>It maybe unclear how <code>1-3</code> help us solve the mountain-goat generation problem; to explain why they are all crucial, we have to first understand some hand wavy game theory.</p><h2 id=better--motivation>(Better) Motivation</h2><p>It&rsquo;s storytime!</p><p>Al Capone and Eliot Ness are playing a game. Al is trying to create counterfeit Franklins, and Eliot is trying to catch them out of circulation.</p><p>Al first uses his HP Inkjet printer to print the currency. Eliot quickly wises up and uses a microscope to observe whether or not a piece of money in question is printed by ink or via color pigmented paper. Not wishing to foil his plan, Al asks his lab to develop new color pigmentation technology&mdash;just like the US currency does!</p><p>Yet, Eliot outsmarts Al again&mdash;he uses a spectrophotometer to analyze whether or not the money in question is made using paper or on cotton like the actual US currency. Seeing this, an angry Al purchases a tonne of cotton and starts printing his counterfeits on cotton.</p><p>Wanting to satisfy Jack&rsquo;s uselessly long analogy, Doctor Strange comes and freezes time for everyone except Al and Eliot (and their respective teams). As the true US currency technology remains the same, Eliot and Al continue to play this game: both developing better technologies to make or catch counterfeits.</p><p>After a billion years, Doctor Strange gets bored and looked into his frozen world. What does he see?</p><p>Al Capone built an exact replica of the US Mint.</p><p>Why? Each time Al gets caught out by Eliot, Al learns one more aspect of how his counterfeit differs from actual US currency. In effect, he&rsquo;s also learning one new detail of how the US currency is made. Therefore, if he keeps patching these tiny differences that Eliot helpfully pointed out for him for the span of a billion years, what Al will be producing will eventually be indistinguishable from US dollars as Eliot will be out of things to point out!</p><p>At this point, the Capone-Ness system has reached what we call <strong>Nash equilibrium</strong>: neither Eliot nor Al have a better move to make&mdash;Eliot no longer has anything more he can possibly do to catch counterfeits as Al&rsquo;s money is identical to US currency, and Al can no longer change his formula for money-making as any deviation will create another factor Eliot can latch onto.</p><h2 id=gans>GANs</h2><p>A <strong>Generative Adversarial Network</strong> (<strong>GAN</strong>) is a multi-modal generation model.</p><p>It is made out of two interacting neural networks:</p><ul><li><strong>generator</strong> \(G(x)\): Al Capone</li><li><strong>discriminator</strong> \(D(x)\): Eliot Ness</li></ul><p>Specifically, the <strong>generator</strong> is an unsupervised model trained on the task of generating the targets (&ldquo;images of mountain goats&rdquo;) from random noise, while the <strong>discriminator</strong> is a <strong>self-supervised model</strong> trained on the task of classifying whether or not something is actually the target (&ldquo;actual images of mountain goats&rdquo;) or the output of the generator.</p><p>The two models converge in tandem, in a similar fashion to the story described above.</p><h3 id=discriminator-d--x>Discriminator \(D(x)\)</h3><p>The <strong>discriminator</strong> \(D(x)\) is perhaps the more easily understandable model out of the two. It is a <strong>self-supervised model</strong> designed with the task of discriminating whether or not a particular input came from the actual world (&ldquo;goat images&rdquo;) or was the output of the <strong>generator</strong>.</p><p>Specifically, the <strong>discriminator</strong> is a neural network with any middle layers you&rsquo;d like that takes the output of the <strong>generator</strong> <em>or</em> real images as input, and produces a single <code>sigmoid</code> activated feature (between 0-1) where \(0\) represents &ldquo;definitely produced by <strong>generator</strong>&rdquo; and \(1\) represents &ldquo;definitely real world.&rdquo;</p><h3 id=generator-g--x>Generator \(G(x)\)</h3><p>The <strong>generator</strong> \(G(x)\) is a model that takes a <em>random tensor</em> as input and attempts to produce a generated sample (&ldquo;a picture of a goat&rdquo;). As with the descriminator, it can have any middle layers you&rsquo;d like but has to produce a tensor with the same shape and activation of an actual sample. For instance, if you are trying to produce images, the output of your <strong>generator</strong> has to be of shape \((channels, x, y)\) activated with <code>sigmoid</code> for brightness; if you are trying to produce single scalars, then the <strong>generator</strong> has to produce only value, etc.</p><p>It is perhaps very mystifying how we would ever build a magical box that takes a random tensor and turn it into a pretend image; looking at the loss functions (i.e. training objectives) of these two networks may perhaps help clarify this.</p><h3 id=loss-functions>Loss Functions</h3><p>Before we begin, I want to quickly reiterate something which will be crucial to your mental framework of the loss functions: <strong>THEY ARE NOT METRICS</strong>. The <em>value</em> of the loss functions&mdash;especially these ones&mdash;are now completely devoid of physical meaning; instead, the <em>trend</em> of the loss functions (&ldquo;value goes down means model is doing better&rdquo;) is what matters.</p><p>We are introducing the simplest form of <strong>GAN</strong> loss functions by <a href=https://arxiv.org/abs/1406.2661>Goodfellow, et al</a> called &ldquo;non-saturating loss.&rdquo; There are better ones, but these ones are mathematically elegant and works most of the time&mdash;and are the &ldquo;base case&rdquo; loss functions which other models improve on.</p><h4 id=descriminator-loss>Descriminator Loss</h4><p>\begin{equation}
L_{d} (\bold{x}_{i}, \bold{z}_{i}) = -\log D(\bold{x}_{i}) - \log (1- D(G(\bold{z}_{i})))
\end{equation}</p><p>where, \(\bold{x}_{i}\) is a tensor representing a real sample (for instance, again, an actual grid of pixels for a mountain goat image), and \(\bold{z}_{i}\) is a tensor containing random noise.</p><p>Woof. This is quite a scary loss function; let&rsquo;s break it up into pieces.</p><ul><li><p>\(-\log D(\bold{x}_{i})\): \(\bold{x}_{i}\) is a real sample, so we expect \(D\) to produce \(1\). Any value below \(1\) (i.e. the <strong>descriminator</strong> thinking a real image is generated) will produce negative values of increasingly larger magnitude as \(D(\bold{x}_{i})\) approaches \(0\). If the descriminator produces \(1\) correctly, \(\log 1 = 0\) and we indeed have converged.</p></li><li><p>\(-\log (1- D(G(\bold{z}_{i})))\): on the flip side, we expect the generator to consider the output of the generator (i.e. \(D(G(\bold{z}_{i}))\)) to be generated and produce \(0\). Therefore, we expect the same scheme as before but flipped (\(1-D(G(\bold{z}_{i})\))&mdash;if \(D(G(\bold{z}))\) produces \(1\) (&ldquo;the descriminator is fooled&rdquo;), \(1-D(G(\bold{z}))\) will produce \(0\) and the loss will be very high. Vise versa: if \(D(G(\bold{z}))\) produces \(0\) (&ldquo;the descriminator picked out the fake&rdquo;), the loss will be \(0\).</p><p>Adding the two values encourages our descriminator to both classify real samples as real \(1\), and generated samples as fake \(0\).</p></li></ul><h4 id=generator-loss>Generator Loss</h4><p>\begin{equation}
L_{g}(\bold{z}_{i}) = -\log (D(G(\bold{z}_{i})))
\end{equation}</p><p>The sharp-eyed among you may realize that this is just the right term from the above expression without the \(1-\) negation. Indeed, the training target for the &ldquo;generator&rdquo; is very simple: &ldquo;did I fool the descriminator&rdquo;?</p><h2 id=the-training-loop>The Training Loop</h2><p>Loss functions in place, we are almost ready to make the model.</p></div></article></main><footer><p id=footer>&copy; 2019-2023 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>