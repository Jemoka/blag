<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS242 OCT220224</title>
<meta name=description content="pairs

Constructor: \(\qty(e,e&rsquo;)\)
Destructor: \(p.l, p.r\) or \(fst\ p\), \(snd\ p\)
Type: \(A * B\)

currying
Consider a function from pairs to a thing: \(A * B \to C\)
We can instead construct a function: \(A \to B \to C: \lambda a . \lambda b. f(a,b)\)
state and exception
Both state and exceptions create &ldquo;side information&rdquo;&mdash;-the side information is threaded through computation in a specific order; we create new primitives for manipulating side information."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS242 OCT220224</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#pairs>pairs</a></li><li><a href=#currying>currying</a></li><li><a href=#state-and-exception>state and exception</a><ul><li><a href=#but-why-not-just-put-it-as-a-pure-function>But why not just put it as a pure function?</a></li></ul></li><li><a href=#exception>exception</a><ul><li><a href=#semantics-of-exceptions>semantics of exceptions</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=pairs>pairs</h2><ul><li>Constructor: \(\qty(e,e&rsquo;)\)</li><li>Destructor: \(p.l, p.r\) or \(fst\ p\), \(snd\ p\)</li><li>Type: \(A * B\)</li></ul><h2 id=currying>currying</h2><p>Consider a function from pairs to a thing: \(A * B \to C\)</p><p>We can instead construct a function: \(A \to B \to C: \lambda a . \lambda b. f(a,b)\)</p><h2 id=state-and-exception>state and exception</h2><p>Both state and exceptions create &ldquo;side information&rdquo;&mdash;-the side information is threaded through computation in a specific order; we create new primitives for manipulating side information.</p><p>This is the typical description of PL:</p><ul><li>some lambda calculus semantics</li><li>additional features that give you escape hatches</li></ul><h3 id=but-why-not-just-put-it-as-a-pure-function>But why not just put it as a pure function?</h3><p>try just put the state in a pair</p><p>\begin{equation}
a * s \to b * s
\end{equation}</p><p>every function must take and expose a state.</p><p>or we can curry the state:</p><p>\begin{equation}
a \to (s \to b * s)
\end{equation}</p><p>In particular, we can create a state transformer: \(M b = s \to b * s\) (i.e. the right side; that is, we can&rsquo;t get the \(b\) out without doing the computation to unwrap \(Mb\) with state)</p><p>THIS IS A <a href=/posts/kbhmonad/>monad</a>!</p><h2 id=exception>exception</h2><p>In an <a href=#exception>exception</a> system, operations has two forms:</p><p>\begin{equation}
E \vdash e \to v
\end{equation}</p><p>or</p><p>\begin{equation}
E \vdash e \to Exc(v)
\end{equation}</p><p>that is, the evaluate produces a normal value, or produce an exception that may wrap an value. Further evaluation must be <em>strict</em> in the exception&mdash;if anyone touches that value, it should return that value unless yo you are a handler.</p><h3 id=semantics-of-exceptions>semantics of exceptions</h3><p>variables</p><p>\begin{equation}
\frac{}{E \vdash x \to E(x)}
\end{equation}</p><p>integers</p><p>\begin{equation}
\frac{}{E \vdash i \to i}
\end{equation}</p><p>closures</p><p>\begin{equation}
\frac{}{E \vdash \lambda x . e \to &lt; \lambda x . e , E >}
\end{equation}</p><p>raising</p><p>\begin{equation}
\frac{E \vdash e \to v}{E \vdash \text{raise } e \to Exc(v)}
\end{equation}</p><p>application, part1: exception propagation in function</p><p>\begin{equation}
\frac{E \vdash e_1 \to Exc(v)}{E \vdash e_1 e_2 \to Exc(v)}
\end{equation}</p><p>application, part2: exception propagation in value</p><p>\begin{equation}
\frac{E \vdash e_1 \to &lt; \lambda x . e_0, E &rsquo; >, E \vdash e_2 \to Exc(v)}{E \vdash e_1 e_2 \to Exc(v)}
\end{equation}</p><p>application, part 3: normal abstractions</p><p>\begin{equation}
\frac{E \vdash e_1 \to &lt; \lambda x . e_0, E&rsquo; >, E \vdash e_2 \to v, E&rsquo;[x: v] \vdash e_0 \to v&rsquo;}{E \vdash e_1 e_2 \to v&rsquo;}
\end{equation}</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>