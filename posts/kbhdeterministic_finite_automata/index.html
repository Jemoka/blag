<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Deterministic Finite Automata</title>
<meta name=description content="Computational memory of this type of model is fixed. In particular, the class of problems this type of automata solves (&ldquo;languages it recognizes&rdquo;) is called regular languages.
We want to explore the closure properties of regular languages (does combining regular languages result in regular languages)
constituents
A DFA is a five-tuple \(M = (Q, \Sigma, \delta, q_{0}, F)\).

\(Q\): finite set of all states
\(\Sigma\): the alphabet
\(\delta: Q \times \Sigma \to Q\), the transition function
\(q_0 \in Q\): the start state
\(F \subseteq Q\): the accept states, which means we accept the input string we got if after processing the string we ended up at one of these states

requirements
if processing an input results in an accepting state, we accept the input; otherwise, we reject the input. this is the computation."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Deterministic Finite Automata</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#constituents>constituents</a></li><li><a href=#requirements>requirements</a><ul><li><a href=#accept>accept</a></li></ul></li><li><a href=#additional-information>additional information</a><ul><li><a href=#l--m>L(M)</a></li><li><a href=#regular-language--kbhregular-language-dot-md><a href=HAHAHUGOSHORTCODE353s5HBHB>regular language</a></a></li><li><a href=#dfas-are-equivalent-to-nfas--kbhnondeterministic-finite-automata-dot-md><a href=HAHAHUGOSHORTCODE353s7HBHB>DFAs are equivalent to NFAs</a></a></li><li><a href=#regular-expression--kbhregex-dot-md--s><a href=HAHAHUGOSHORTCODE353s11HBHB>regular expression</a>s</a></li></ul></li><li><a href=#examples-and-factoids>examples and factoids</a><ul><li><a href=#why-dfa--kbhdeterministic-finite-automata-dot-md--s>why <a href=HAHAHUGOSHORTCODE353s13HBHB>DFA</a>s?</a></li><li><a href=#limitations-of-dfa--kbhdeterministic-finite-automata-dot-md--s>Limitations of <a href=HAHAHUGOSHORTCODE353s14HBHB>DFA</a>s</a></li><li><a href=#simple-things-to-make-and-do-with-dfa--kbhdeterministic-finite-automata-dot-md--s-because-they-are-so-simple>simple things to make and do with <a href=HAHAHUGOSHORTCODE353s18HBHB>DFA</a>s because they are so simple</a></li><li><a href=#examples>examples</a></li><li><a href=#pumping-lemma--kbhpumping-lemma-dot-md><a href=HAHAHUGOSHORTCODE353s26HBHB>pumping lemma</a></a></li><li><a href=#minimizing-dfas--kbhminimizing-dfas-dot-md><a href=HAHAHUGOSHORTCODE353s28HBHB>Minimizing DFAs</a></a></li><li><a href=#learning-dfa>Learning DFA</a></li></ul></li></ul></nav></aside><main><article><div><p><strong>Computational memory</strong> of this type of model is fixed. In particular, the class of problems this type of automata solves (&ldquo;languages it recognizes&rdquo;) is called <a href=/posts/kbhdeterministic_finite_automata/>regular languages</a>.</p><p>We want to explore the <strong>closure</strong> properties of regular languages (does combining <a href=/posts/kbhdeterministic_finite_automata/>regular languages</a> result in <a href=/posts/kbhdeterministic_finite_automata/>regular languages</a>)</p><h2 id=constituents>constituents</h2><p>A DFA is a five-tuple \(M = (Q, \Sigma, \delta, q_{0}, F)\).</p><ul><li>\(Q\): finite set of all states</li><li>\(\Sigma\): the <a href=/posts/kbhalphabet/>alphabet</a></li><li>\(\delta: Q \times \Sigma \to Q\), the transition function</li><li>\(q_0 \in Q\): the start state</li><li>\(F \subseteq Q\): the accept states, which means we accept the input string we got if after processing the string we ended up at one of these states</li></ul><h2 id=requirements>requirements</h2><p>if processing an input results in an accepting state, we accept the input; otherwise, we reject the input. this is the computation.</p><h3 id=accept>accept</h3><p>Let \(w_1, &mldr;, w_{n} \in \Sigma\), and \(w = w_1 &mldr; w_{n} \in \Sigma^{*}\), \(M\) <strong>accepts</strong> \(w\) if there exists \(r_0, &mldr;, r_{n} \in Q\) such that:</p><ul><li>\(r_{0} = q_{0}\)</li><li>\(\delta(r_{i}, w_{i+1}) = r_{i+1}\) for all \(i=0, &mldr;, n-{1}\), and</li><li>\(r_{n} \in F\)</li></ul><h2 id=additional-information>additional information</h2><h3 id=l--m>L(M)</h3><p>the set of all <a href=/posts/kbhalphabet/>string</a>s that \(M\) <strong>accepts</strong> is called the &ldquo;language recognized by \(M\)&rdquo;, or &ldquo;the function computed by \(M\)&rdquo;.</p><p>important factoid: <strong>empty language is <em>not</em> the empty string, the empty language contains no strings, the empty string contains no content, which means you stay at \(q_0\)</strong></p><h3 id=regular-language--kbhregular-language-dot-md><a href=/posts/kbhregular_language/>regular language</a></h3><p>see <a href=/posts/kbhregular_language/>regular language</a></p><h3 id=dfas-are-equivalent-to-nfas--kbhnondeterministic-finite-automata-dot-md><a href=/posts/kbhnondeterministic_finite_automata/#id-4f5a240b-565b-4341-ab32-0b8b4540103f-dfa-s-are-equivalent-to-id-5520de84-0c82-4b31-97cb-51f7de4652dc-nfa-s>DFAs are equivalent to NFAs</a></h3><p>see <a href=/posts/kbhnondeterministic_finite_automata/#id-4f5a240b-565b-4341-ab32-0b8b4540103f-dfa-s-are-equivalent-to-id-5520de84-0c82-4b31-97cb-51f7de4652dc-nfa-s>DFAs are equivalent to NFAs</a></p><p><a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s recognize the same set of languages as <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>s, that is, regular languages.</p><h3 id=regular-expression--kbhregex-dot-md--s><a href=/posts/kbhregex/>regular expression</a>s</h3><p>see <a href=/posts/kbhregular_expression_complexity/>regular expression</a></p><h2 id=examples-and-factoids>examples and factoids</h2><h3 id=why-dfa--kbhdeterministic-finite-automata-dot-md--s>why <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s?</h3><ul><li>constant size memory => <strong>important</strong>, dynamically adding memory does bring more computational power</li><li>read input once => <strong>unimportant</strong>, being able to go back and fourth doesn&rsquo;t add additional computational power</li></ul><p><strong>original introduction of nondeterminism</strong></p><h3 id=limitations-of-dfa--kbhdeterministic-finite-automata-dot-md--s>Limitations of <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s</h3><ul><li><a href=/posts/kbhpumping_lemma/>pumping lemma</a></li><li><a href=/posts/kbhmyhill_nerode/>Myhill-Nerode</a> (entire characterization of <a href=/posts/kbhdeterministic_finite_automata/>regular languages</a>)</li></ul><h3 id=simple-things-to-make-and-do-with-dfa--kbhdeterministic-finite-automata-dot-md--s-because-they-are-so-simple>simple things to make and do with <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s because they are so simple</h3><ul><li>optimize <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>: for a given <a href=/posts/kbhdeterministic_finite_automata/>regular language</a>, what is the smallest <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>?</li><li>learning <a href=/posts/kbhdeterministic_finite_automata/>DFA</a></li></ul><h3 id=examples>examples</h3><h4 id=proof-this-language-accepts-an-odd-number-of-1>proof: this language accepts an odd number of \(1\)</h4><figure><img src=/ox-hugo/2024-09-30_19-38-45_screenshot.png></figure><p>We show this by induction on the string length.</p><ul><li>base, this string has zero length, and we reject the string</li><li>suppose for a string of length \(n\), \(M\) accepts \(n\) IFF \(n\) has an odd number of \(1\)</li><li>now, consider a string of length \(n+1\), casework:<ul><li>we are at an accept state, and we got a \(0\): this means we still have an odd number of \(1\), we don&rsquo;t go anywhere, we can accept</li><li>we are at an reject state, and we got a \(1\): this means we now have an odd number of \(1\), we go to \(q\), and we can accept</li><li>&mldr;.</li></ul></li></ul><h4 id=build-a-dfa-that-accepts-at-least-strings-that-contain-001>build a DFA that accepts at least strings that contain \(001\)</h4><figure><img src=/ox-hugo/2024-09-30_19-48-17_screenshot.png></figure><p>this requires some thinking, and the trick is simply keeping track of what you saw in the states, and if you saw something contradictory backtrak if needed</p><h4 id=constructing-a-binary-addition-system>constructing a binary addition system</h4><figure><img src=/ox-hugo/2024-10-01_11-42-54_screenshot.png></figure><h3 id=pumping-lemma--kbhpumping-lemma-dot-md><a href=/posts/kbhpumping_lemma/>pumping lemma</a></h3><p>see <a href=/posts/kbhpumping_lemma/>pumping lemma</a></p><h3 id=minimizing-dfas--kbhminimizing-dfas-dot-md><a href=/posts/kbhminimizing_dfas/>Minimizing DFAs</a></h3><p>see <a href=/posts/kbhminimizing_dfas/>Minimizing DFAs</a></p><h3 id=learning-dfa>Learning DFA</h3><p>See <a href=/posts/kbhpac_learning/>PAC Learning</a></p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>