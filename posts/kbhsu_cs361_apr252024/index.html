<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS361 APR252024</title>
<meta name=description content="Linear Constraint Optimization \begin{align} \min_{x}\ &amp;c^{\top} x \\ s.t.\ &amp;Ax \leq b \\ & x \geq 0 \end{align}
linear objective function linear constraints single our inequality forms a half-space; the entire feasible set is denoted by a series of linear functions&mdash;-these linear equalities are each CONVEX.
This makes a Linear Program have a single minimum.
3 cases of design points points on the interior of feasible set is always non-optimal, because we can always move along \(c\) gradient points on the faces could be optimal IFF the face is perpendicular to \(c\), the gradient of our objective function&mdash;but you can always slide along the face, making there be infinite solutions if its on a face (because \(c\) doesn&rsquo;t change along that face) points on vertex could be optimal linear program equality form \begin{align} \min_{x}\ &amp;c^{\top} x \\ s."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS361 APR252024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#linear-constraint-optimization>Linear Constraint Optimization</a><ul><li><a href=#3-cases-of-design-points>3 cases of design points</a></li><li><a href=#linear-program-equality-form>linear program equality form</a></li><li><a href=#fonc--kbhsu-cs361-apr042024-dot-md--for-linear-program><a href=HAHAHUGOSHORTCODE1256s1HBHB>FONC</a> for linear program</a></li></ul></li><li><a href=#vertex-partitioning>vertex partitioning</a><ul><li><a href=#get-vertex>get vertex</a></li></ul></li><li><a href=#simplex-algorithm>simplex algorithm</a><ul><li><a href=#phase-1>Phase 1</a></li><li><a href=#phase-2>Phase 2</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=linear-constraint-optimization>Linear Constraint Optimization</h2><p>\begin{align}
\min_{x}\ &amp;c^{\top} x \\
s.t.\ &amp;Ax \leq b \\
& x \geq 0
\end{align}</p><ul><li>linear objective function</li><li>linear constraints</li></ul><p>single our inequality forms a half-space; the entire <a href=/posts/kbhsu_cs361_apr022024/#formal-formulation-of-optimization>feasible set</a> is denoted by a series of linear functions&mdash;-these linear equalities are each <strong>CONVEX</strong>.</p><p>This makes a <a href=#linear-constraint-optimization>Linear Program</a> have a single minimum.</p><h3 id=3-cases-of-design-points>3 cases of design points</h3><ol><li><strong>points on the interior of feasible set</strong> is always non-optimal, because we can always move along \(c\) gradient</li><li><strong>points on the faces</strong> could be optimal IFF the face is perpendicular to \(c\), the gradient of our objective function&mdash;but you can always slide along the face, making there be <em>infinite solutions</em> if its on a face (because \(c\) doesn&rsquo;t change along that face)</li><li><strong>points on vertex</strong> could be optimal</li></ol><h3 id=linear-program-equality-form>linear program equality form</h3><p>\begin{align}
\min_{x}\ &amp;c^{\top} x \\
s.t.\ &amp;Ax = b \\
& x \geq 0
\end{align}</p><p>We can transpose our standard-form expression into an equality form above by introducing another &ldquo;slack variable&rdquo; \(s\), such that we write:</p><p>\begin{equation}
Ax \leq b \implies Ax + s = b
\end{equation}</p><p>and introducing \(s > 0\) as another constraint.</p><h3 id=fonc--kbhsu-cs361-apr042024-dot-md--for-linear-program><a href=/posts/kbhsu_cs361_apr042024/#first-order-necessary-condition>FONC</a> for linear program</h3><p>To convert a linear program into a unconstrained program&mdash;</p><p>Recall our <a href=/posts/kbhsu_cs361_apr182024/#kkt-conditions>KKT Conditions</a>:</p><p>\begin{align}
\mathcal{L} = c^{\top} x - \mu^{\top} - \lambda^{\top} (Ax - b)
\end{align}</p><ul><li>feasibility: \(Ax = b, x \geq 0\) (satisfies our constraints)</li><li>dual feasibility: \(\mu \geq 0\)</li><li>complementary slackness: \(u \odot x = 0\)</li><li>stationarity: \(A^{\top}\lambda + \mu = c\)</li></ul><p>So:</p><p>\begin{equation}
\min_{x} \max_{\mu \geq 0, \lambda} \mathcal{L}(x,\mu)
\end{equation}</p><p>For linear programs, is that <a href=/posts/kbhsu_cs361_apr042024/#first-order-necessary-condition>FONC</a> are sufficient by themselves!</p><h2 id=vertex-partitioning>vertex partitioning</h2><p>Consider \(n\), the number of design variables \(x\); and \(m\), the number of equality constraints in <a href=#linear-program-equality-form>linear program equality form</a>; the number of vertices gives \(n-m\).</p><p>We can map each of our vertices to a basis by chopping off some dimensions and applying our map \(A\).</p><h3 id=get-vertex>get vertex</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>LinearProgram</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#111>A</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>c</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_vertex</span><span style=color:#111>(</span><span style=color:#111>basis</span><span style=color:#111>,</span> <span style=color:#111>LP</span><span style=color:#111>:</span><span style=color:#111>LinearProgram</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>A</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>,</span><span style=color:#111>c</span> <span style=color:#f92672>=</span> <span style=color:#111>LP</span><span style=color:#f92672>.</span><span style=color:#111>A</span><span style=color:#111>,</span> <span style=color:#111>LP</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>LP</span><span style=color:#f92672>.</span><span style=color:#111>c</span>
</span></span><span style=display:flex><span>    <span style=color:#111>b_indicies</span> <span style=color:#f92672>=</span> <span style=color:#111>sort</span><span style=color:#111>(</span><span style=color:#111>basis</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>AB</span> <span style=color:#f92672>=</span> <span style=color:#111>A</span><span style=color:#111>[:,</span><span style=color:#111>b_inds</span><span style=color:#111>]</span>
</span></span><span style=display:flex><span>    <span style=color:#111>xB</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span>
</span></span></code></pre></div><h2 id=simplex-algorithm>simplex algorithm</h2><ol><li>find vertices</li><li>check for <a href=#fonc--kbhsu-cs361-apr042024-dot-md--for-linear-program>FONC for linear program</a></li><li>if done, return</li></ol><hr><h3 id=phase-1>Phase 1</h3><p>Choose an initial partition which gives an initial vertex:</p><p>\begin{align}
\min_{x,z}\ &\mqty[0^{\top}, 1^{\top}] \mqty[x \\ z] \\
s.t.\ &\mqty[A, Z] \mqty[x \\ z] = b \\
& \mqty[x \\ z] \geq 0
\end{align}</p><p>where:</p><p>\begin{equation}
Z_{ii} = \begin{cases}
1, \text{if}\ b_{i} \geq 0 \\
-1
\end{cases}
\end{equation}</p><p>the <strong>partition</strong> obtained by solving this system will give \(Ax = b\); if the \(z\) returned is <em>nonzero</em>, this makes the original problem <strong>infeasible</strong>.</p><p>We initialize this system because we have a known initial partition we can solve \(\mathcal{B} = \{n+1, &mldr;, n+m\}\).</p><p>Once we get a final set \(\mathcal{B}\), we can then solve the final expression:</p><p>\begin{align}
\min_{x,z}\ &\mqty[c^{\top} & 0^{\top}] \mqty[x \\ z] \\
s.t.\ &\mqty[A & I \\ 0 & I] \mqty[x \\ z] = \mqty[b \\ 0] \\
& \mqty[x \\ z] \geq 0
\end{align}</p><h3 id=phase-2>Phase 2</h3><p>Consider an initial partition \(\mathcal{B}\); choose an entering index \(q \in \mathcal{V}\), and a leaving index \(p \in \mathcal{B}\), and a leaving index \(p \in \mathcal{B}\).</p><p>&mldr;.</p><p>\begin{equation}
x_{\mathcal{B}}&rsquo; = x_{\mathcal{B}} - A^{-1}_{\mathcal{B}} A_{\{q\}} x_{q}'
\end{equation}</p><p>and:</p><p>\begin{equation}
c^{\top} x&rsquo; - c^{\top} x = \mu_{q} x_{q}'
\end{equation}</p><p>First choose an <em>entering</em> index \(q\), then solve for leaving index \(p\)</p><p>\begin{equation}
x_{q}&rsquo; = \frac{(x_{\mathcal{B}})_{p}}{(A_{\mathcal{B}}^{-1} A_{\{q\}})_{p}}
\end{equation}</p><p>we then go through each possible candidate \(q \in \mathcal{V}\), and within each of those we iterate trough peach possible \(p \in \mathcal{B}\), and find the pair \((p,q)\) for each \(q\) which gives the smallest ratio above. we then greedily return the swap pair which minimizes \(\mu_{q} x_{q}&rsquo;\).</p><p>We can solve for our lagrange multiplies by:</p><p>\begin{equation}
\lambda = A^{-\top}_{\mathcal{B}} c_{\mathcal{B}}
\end{equation}</p><p>and:</p><p>\begin{equation}
u_{\mathcal{V}} = c_{\mathcal{V}} - A^{\top}_{\mathcal{V}} \lambda
\end{equation}</p><p>A node is a candidate \(q\) if \(u_{\mathcal{V}}[q] &lt; 0\) , which is the only one that satisfies FONC.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>