<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Numerical Stability</title>
<meta name=description content="&ldquo;being careful&rdquo;
numerically stable vector norms
consider:
\begin{equation}
\Vert x \Vert_{2} = \sqrt{x_1^{2} + \dots + x_{m}^{2}}
\end{equation}
squaring it could easily go over MAX-float for large \(m\). Instead, consider:
\begin{equation}
\Vert x \Vert_{2} = z \sqrt{\qty(\frac{x_1}{z})^{2} + \dots \qty(\frac{x_{m}}{z})^{2}}
\end{equation}
where \(z = \max_{i} |x_{i}|\). Notice how now we are squaring numbers which are less than one, meaning this will never blow up. Yet, the results will be the same. This is bounded, therefore, by \(m\)."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Numerical Stability</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#numerically-stable-vector-norms>numerically stable vector norms</a></li><li><a href=#numerically-stable-quadratic-formula>numerically stable quadratic formula</a></li><li><a href=#numerically-stable-l-hospital-s>numerically stable l&rsquo;hospital&rsquo;s</a></li></ul></nav></aside><main><article><div><p>&ldquo;being careful&rdquo;</p><h2 id=numerically-stable-vector-norms>numerically stable vector norms</h2><p>consider:</p><p>\begin{equation}
\Vert x \Vert_{2} = \sqrt{x_1^{2} + \dots + x_{m}^{2}}
\end{equation}</p><p>squaring it could easily go over MAX-float for large \(m\). Instead, consider:</p><p>\begin{equation}
\Vert x \Vert_{2} = z \sqrt{\qty(\frac{x_1}{z})^{2} + \dots \qty(\frac{x_{m}}{z})^{2}}
\end{equation}</p><p>where \(z = \max_{i} |x_{i}|\). Notice how now we are squaring numbers which are less than one, meaning this will never blow up. Yet, the results will be the same. This is bounded, therefore, by \(m\).</p><h2 id=numerically-stable-quadratic-formula>numerically stable quadratic formula</h2><p>quadratic formula on small floating points give very wrong results after rounding (since \(b - \sqrt{b^{2}-4ac}\) maybe very close to \(0\)).</p><p>If we derationalize (multiply by rational on top and bottom):</p><p>\begin{equation}
\frac{2c}{-b \pm \sqrt{b^{2}-4ac}}
\end{equation}</p><p>this actually gets the other root wrong: i.e. the one which was fine on the other one (the \(b+\ldots\) case).</p><p>The takeaway is to use the normal one:</p><p>\begin{equation}
\frac{-b + \sqrt{b^{2}-4ac}}{2a}
\end{equation}</p><p>for the plus case and the derationalized one:</p><p>\begin{equation}
\frac{2c}{-b + \sqrt{b^{2} - 4ac}}
\end{equation}</p><p>for the other root. (If \(-b\) is negative, then flip the \(\pm\) signs to avoid cancellation).</p><h2 id=numerically-stable-l-hospital-s>numerically stable l&rsquo;hospital&rsquo;s</h2><p>Evaluating:</p><p>\begin{equation}
\frac{x^{2}-4}{x-2}
\end{equation}</p><p>near \(x=2\), where it becomes \(\frac{0}{0}\), is really bad and will lead to instability.</p><p>Naively doing:</p><p>\begin{equation}
\frac{x^{2}-4}{(x-2)+\epsilon}
\end{equation}</p><p>is also bad because it goes to \(0\) near \(x=2\), instead of the correct value which is near \(x+2\). Even worse, the derivative of this goes to an insane amount of error as you string \(\epsilon\) near \(x=2\), because the curve becomes increasingly sharper.</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>