<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS361 APR302024</title>
<meta name=description content="Dual Certificates Dual Certificates is a method of, given some proposed solution \(x^{*}\) of the primal problem for a Linear Program, we can verify the solution with the dual solution.
Recall the dual form of the primal problem:
\begin{align} \max_{\lambda}\ &amp;b^{\top}\lambda\\ s.t.\ &amp;A^{\top} \lambda \leq c \end{align}
Typically, this would give us an lower bound to the primal solution. However, for Linear Programs, they are equal.
So, given some \((x^{*}, \lambda^{*})\), we can verify it by checking:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS361 APR302024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#dual-certificates>Dual Certificates</a></li><li><a href=#multi-objective-optimization>Multi-Objective Optimization</a><ul><li><a href=#pareto-optimality>Pareto Optimality</a></li><li><a href=#pareto-frontier>Pareto Frontier</a></li><li><a href=#utopia-point>Utopia Point</a></li><li><a href=#multi-objective-population-method>Multi-Objective Population Method</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=dual-certificates>Dual Certificates</h2><p><a href=#dual-certificates>Dual Certificates</a> is a method of, given some proposed solution \(x^{*}\) of the <a href=/posts/kbhsu_cs361_apr182024/#primal-problem>primal problem</a> for a <a href=/posts/kbhsu_cs361_apr252024/#linear-constraint-optimization>Linear Program</a>, we can verify the solution with the dual solution.</p><hr><p>Recall the <a href=/posts/kbhsu_cs361_apr182024/#dual-form-of-the-primal-problem>dual form of the primal problem</a>:</p><p>\begin{align}
\max_{\lambda}\ &amp;b^{\top}\lambda\\
s.t.\ &amp;A^{\top} \lambda \leq c
\end{align}</p><p>Typically, this would give us an <strong>lower bound</strong> to the primal solution. However, for <a href=/posts/kbhsu_cs361_apr252024/#linear-constraint-optimization>Linear Program</a>s, they are <strong>equal</strong>.</p><hr><p>So, given some \((x^{*}, \lambda^{*})\), we can verify it by checking:</p><ol><li>primal feasible: \(Ax \leq b\), \(x \geq 0\)</li><li>dual feasible: \(A^{\transpose} \lambda \leq c\)</li><li>dual certificate: \(c^{\top} x^{*} = b^{\top} \lambda^{*}\)</li></ol><p>This allows us to check, for a given solution, whether or not it is actually the correct solution.</p><h2 id=multi-objective-optimization>Multi-Objective Optimization</h2><ol><li>identify non-dominated individuals (individuals, for which in the multi-objective, is not <strong>dominated</strong>); this forms the &ldquo;pareto frontier&rdquo;</li><li>create all combinations of input parameters, and create a pareto frontier for them</li><li>identify a weighting between the variations you desire, and identify the elements which align with the Pareto frontier</li></ol><h3 id=pareto-optimality>Pareto Optimality</h3><p>At a <a href=#pareto-optimality>pareto optimal</a> point, increasing one objective value decreases another. that is, a <a href=#pareto-optimality>pareto optimal</a> point is not <a href=#dominate>dominate</a>d.</p><h4 id=dominate>dominate</h4><p>one point <a href=#dominate>dominate</a>s another if:</p><p>\begin{align}
f_{i}(x) \leq f_{i}(x&rsquo;) \forall i \\
f_{i}(x) &lt; f_{i}(x&rsquo;)\ \text{for some}\ i
\end{align}</p><h3 id=pareto-frontier>Pareto Frontier</h3><p>A Pareto frontier is the entire set of <a href=#pareto-optimality>pareto optimal</a> points&mdash;i. the set that&rsquo;s not dominated.</p><h4 id=solving-for-pareto-frontier>Solving for Pareto Frontier</h4><ul><li><p>Constraint Method</p><p>We can convert this into a single-objective optimization problem; first, sort the constraints by order of importance:</p><p>\begin{align}
\min_{x}&\ f_{1}(x) \\
s.t.&\ f_2(x) \leq c_2 \\
&\ f_3(x) \leq c_3 \\
&\ \dots
\end{align}</p><p>we can set \(c_{j}\) to calibrate which point we want on our <a href=#pareto-frontier>Pareto Frontier</a>. By setting \(c_{j}\) large, we identify that we don&rsquo;t care about that constraint as much; as we track \(c_{j}\) small, we start tracing out the Frontier along the \(j\) th direction. At some point, as you lower \(c_{j}\), we will run out of points because we would have left the criterion space.</p></li></ul><ul><li><p>Lexicographic Method</p><p>Iteratively perform optimization; again sort constraints in order of importance, then:</p><figure><img src=/ox-hugo/2024-04-30_10-05-13_screenshot.png></figure></li></ul><ul><li><p>Weight Method</p><p>you can use a linear weight to obtain <em>some</em> Pareto optimal answers:</p><p>\begin{equation}
f = w^{\top}\mqty[f_1 \\ \dots\\f_{N}]
\end{equation}</p><p>this fits a line against the Pareto region, which will miss some points but will give some Pareto optimal answers&mdash;there will not be any weighting which preserves points in the zone.</p><figure><img src=/ox-hugo/2024-04-30_10-08-25_screenshot.png></figure></li></ul><ul><li><p>Goal Programming</p><p>\begin{align}
\min_{x \in \mathcal{X}} \mid f(x) - y^{goal} \mid_{p}
\end{align}</p><p>just minimize some distance (L1, L2, L-inf norms are all good) to a &ldquo;good&rdquo; point, usually the <a href=#utopia-point>Utopia Point</a>.</p><p>L1 norms have the same problem as <a href=#weight-method>Weight Method</a> as it is a line.</p></li></ul><h3 id=utopia-point>Utopia Point</h3><p>The <a href=#utopia-point>Utopia Point</a> is the most optimal point, component wise.</p><h3 id=multi-objective-population-method>Multi-Objective Population Method</h3><h4 id=classic-population-method>Classic population method</h4><ul><li>create \(m\) subpopulations</li><li>optimize each population for one objective</li><li>shuffle them together after each cohort&rsquo;s optimization, create crossovers and mutations</li></ul><p>This method is good to get the pareto frontier, but often we get clumping at the extremas of each objective. Often, we try to encourage dispersion.</p><h4 id=non-dominating-ranking>Non-Dominating Ranking</h4><p>You can rank all points (including those not on the <a href=#pareto-frontier>Pareto Frontier</a>), with</p><ol><li>pareto-frontier</li><li>non-dominated except for 1)</li><li>non-dominated except 1) or 2)</li><li>&mldr;</li></ol><h4 id=pareto-filter>Pareto filter</h4><p>Identify points on the <a href=#pareto-frontier>Pareto Frontier</a>, and keep top k, perhaps with dispersion</p><h4 id=niche-technique>Niche Technique</h4><p>a <strong>niche</strong> disperses the design along the <a href=#pareto-frontier>Pareto Frontier</a></p><ul><li><a href=#niche-technique>fitness sharing</a>: penalize if neighbors are too close)</li><li><a href=#niche-technique>equivalence class sharing</a>: if two individuals are compared, their non-dominating ranks are compared first, then <a href=#niche-technique>fitness sharing</a> is used as a tie breaker</li></ul></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>