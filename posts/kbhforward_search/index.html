<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Forward Search</title><meta name=description content="Ingredients:

\(\mathcal{P}\) problem (states, transitions, etc.)
\(d\) depth (how many next states to look into)&mdash;more is more accurate but slower
\(U\) value function estimate at depth \(d\)

We essentially roll forward into all possible next states up to depth \(d\), and tabulate our value function.
Define subroutine forward_search(depth_remaining, value_function_estimate_at_d, state).

if depth_remaining=0; return (action=None, utility=value_function_estimate_at_d(state))
otherwise,

let best = (action = None, utility = -infinity)
for each possible action at our state

get an action-value for our current state where the utility of each next state is the utility given by forward_search(depth_remaining-1, value_function_estimate_at_d, next_state)
if the action-value is higher than what we have, then we set best=(a, action-value)


return best



What this essentially does is to Dijkstra an optimal path towards the highest final utility \(U(s)\) om your current state, by trying all states."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Forward Search</h1><span class=tagbox></span></div><main><article><div><p>Ingredients:</p><ul><li>\(\mathcal{P}\) problem (states, transitions, etc.)</li><li>\(d\) depth (how many next states to look into)&mdash;more is more accurate but slower</li><li>\(U\) <a href=/posts/kbhaction_value_function/#value-function--kbhaction-value-function-dot-md>value function</a> estimate at depth \(d\)</li></ul><p>We essentially roll forward into all possible next states up to depth \(d\), and tabulate our <a href=/posts/kbhaction_value_function/#value-function--kbhaction-value-function-dot-md>value function</a>.</p><p>Define subroutine <code>forward_search(depth_remaining, value_function_estimate_at_d, state)</code>.</p><ol><li>if <code>depth_remaining=0</code>; return <code>(action=None, utility=value_function_estimate_at_d(state))</code></li><li>otherwise,<ol><li>let <code>best = (action = None, utility = -infinity)</code></li><li>for each possible action at our state<ol><li>get an <a href=/posts/kbhaction_value_function/>action-value</a> for our current state where the <a href=/posts/kbhutility_theory/>utility</a> of each next state is the utility given by <code>forward_search(depth_remaining-1, value_function_estimate_at_d, next_state)</code></li><li>if the <a href=/posts/kbhaction_value_function/>action-value</a> is higher than what we have, then we set <code>best=(a, action-value)</code></li></ol></li><li>return <code>best</code></li></ol></li></ol><p>What this essentially does is to Dijkstra an optimal path towards the highest final utility \(U(s)\) om your current state, by trying all states.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>