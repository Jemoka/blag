<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS361 APR092024</title>
<meta name=description content="More Bracketing Methods
Quadratic search
if your function is unimodal&mldr;

Pick three points that gets &ldquo;high, low, high&rdquo;
Fit a quadratic to it, evaluate its minima and add it to the point set
Now, drop any of the four resulting point

Shubert-Piyavskill Method
This is a Bracketing approach which grantees optimality WITHOUT unimodality by using the Lipschitz Constant. But, this only works in one dimension.
Consider a Lipschitz continuous function with Lipschitz Constant \(L\). We can get our two initial points \(a\) and \(b\). First, we arbitrarily pick a point in the middle to evaluate; this will give us a cone (see Lipschitz Condition) which bounds the function."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS361 APR092024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#more-bracketing-methods>More Bracketing Methods</a><ul><li><a href=#quadratic-search>Quadratic search</a></li><li><a href=#shubert-piyavskill-method>Shubert-Piyavskill Method</a></li><li><a href=#bisection-method>Bisection Method</a></li></ul></li><li><a href=#local-descent>Local Descent</a><ul><li><a href=#descent-direction-iteration>Descent Direction Iteration</a></li><li><a href=#line-search>Line Search</a></li><li><a href=#trust-region-methods>Trust Region Methods</a></li></ul></li><li><a href=#termination-conditions>Termination Conditions</a><ul><li><a href=#maximum-iterations>Maximum Iterations</a></li><li><a href=#absolute-improvement>Absolute Improvement</a></li><li><a href=#relative-improvement>Relative Improvement</a></li><li><a href=#gradient>Gradient</a></li></ul></li><li><a href=#first-order-methods>First-Order Methods</a><ul><li><a href=#gradient-descent--kbhlogistic-regression-dot-md><a href=HAHAHUGOSHORTCODE1316s11HBHB>gradient descent</a></a></li><li><a href=#conjugate-gradient>Conjugate Gradient</a></li><li><a href=#momentum>Momentum</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=more-bracketing-methods>More Bracketing Methods</h2><h3 id=quadratic-search>Quadratic search</h3><p>if your function is <a href=/posts/kbhunimodal/>unimodal</a>&mldr;</p><ul><li>Pick three points that gets &ldquo;high, low, high&rdquo;</li><li>Fit a quadratic to it, evaluate its minima and add it to the point set</li><li>Now, drop any of the four resulting point</li></ul><h3 id=shubert-piyavskill-method>Shubert-Piyavskill Method</h3><p>This is a <a href=/posts/kbhsu_cs361_apr042024/#bracketing>Bracketing</a> approach which grantees optimality <strong>WITHOUT unimodality</strong> by using the <a href=/posts/kbhuniqueness_and_existance/#lipschitz-condition>Lipschitz Constant</a>. But, this only works in <strong>one dimension</strong>.</p><p>Consider a <a href=/posts/kbhuniqueness_and_existance/#lipschitz-condition>Lipschitz continuous</a> function with <a href=/posts/kbhuniqueness_and_existance/#lipschitz-condition>Lipschitz Constant</a> \(L\). We can get our two initial points \(a\) and \(b\). First, we arbitrarily pick a point in the middle to evaluate; this will give us a cone (see <a href=/posts/kbhuniqueness_and_existance/#lipschitz-condition>Lipschitz Condition</a>) which bounds the function.</p><p>We will then evaluate the function + draw a new cone at each of our ed points \(a, b\). By piecing together the cones, we now obtain a sawtooth which lower bounds our function. We will continue this by choosing the lowest point on our lower bound, reevaluating, raising it to the new sawtooth.</p><p>For instance, in maximization, we can end up with sawtooths like:</p><figure><img src=/ox-hugo/2024-04-09_09-29-57_screenshot.png></figure><h3 id=bisection-method>Bisection Method</h3><p>like <a href=/posts/kbhnewton_s_method/>Newton&rsquo;s Method</a>, this is a ROOT FINDING METHOD which we are coopting to find the minima by solving for <a href=/posts/kbhsu_cs361_apr042024/#first-order-necessary-condition>FONC</a> within an interval.</p><p>bisect \(f&rsquo;(x)\) by sampling points in the middle of the &ldquo;valid interval&rdquo; until you find the point which gives \(f&rsquo;(x) = 0\).</p><p>You do this by sampling points on each edge ensuring that there is a sign switch between each edge (i.e. there is a root between the edge points), and then sampling the middle of the interval. You know that there is a sign switch somewhere by the intermediate value theorem.</p><h2 id=local-descent>Local Descent</h2><h3 id=descent-direction-iteration>Descent Direction Iteration</h3><p><a href=#descent-direction-iteration>Descent Direction Iteration</a> is a class of method that uses a &ldquo;local model&rdquo; to improve the design point until we converge.</p><ol><li>check whether our current \(\bold{x}\) meets our termination conditions; if not&mldr;</li><li>calculate some descent direction \(\bold{d}\) to update our \(\bold{x}\); sometimes, people say it has to be normalized</li><li>decide some step size \(\alpha\)</li><li>have fun: \(\bold{x} \leftarrow \bold{x} + \alpha \bold{d}\)</li></ol><h3 id=line-search>Line Search</h3><p>We can choose the step size \(\alpha\) to perform using line search; i.e., figure out our \(\bold{d}\) somehow, and then use any of the <a href=/posts/kbhsu_cs361_apr042024/#bracketing>Bracketing</a> methods (or grid it up) to solve:</p><p>\begin{equation}
\min_{\alpha} f(\bold{x} + \alpha \bold{d})
\end{equation}</p><h4 id=decaying-alpha>Decaying \(\alpha\)</h4><p>We can also give up solving for the greatest \(\alpha\), fix a learning rate, and then decay it using \(\alpha \gamma^{n}\) where \(n\) is the number of iterations and \(\gamma\) is the decay rate.</p><h4 id=approximate-line-search>Approximate Line Search</h4><p>Instead of continuously evaluating the function \(f\), we use a first order approximation on our directional derivative (plus some acceptability factor \(\beta \in [0,1]\), usually \(\beta=1 \times 10^{-4}\)).</p><p>We will then choose the largest \(\alpha\) that satisfies</p><ul><li><p>Sufficient Decrease Condition</p><p>\begin{equation}
f(x_{t+1}) \leq f(x_{t}) + \beta \alpha \nabla_{d} f(x_{t})
\end{equation}</p></li></ul><ul><li><p>Curvature Condition</p><figure><img src=/ox-hugo/2024-04-09_10-01-52_screenshot.png></figure><p>which bounds the &ldquo;shallowness&rdquo; of the directional derivatives.</p></li></ul><h3 id=trust-region-methods>Trust Region Methods</h3><p>We often want to bound our change in \(x\) by some region \(\delta\) in our steps; so, we really want to&mldr;</p><p>\begin{align}
\min_{x&rsquo;}\ &amp;f(x&rsquo;) \\
s.t.\ & \mid x-x&rsquo; \mid \leq \delta
\end{align}</p><p>To figure \(\delta\), we shrink our region of trust based on the quality of our function estimate (if we used a first-order local model to figure our descent direction, we will use our first order estimate for \(\hat{f}\)):</p><p>\begin{align}
\eta = \frac{f(x)-f(x&rsquo;)}{f(x)-\hat{f}(x&rsquo;)}
\end{align}</p><p>if \(\eta &lt; \eta_{1}\), we would scale down \(\delta\) by some amount as evidently our actual improvement is smaller than expected and reject our new point; if \(\eta > \eta_{2}\), we will accept our new point and scale up \(\delta\) by some amount as our improvement is better than expected. Otherwise, we will accept the new point an do not nothing to the trust region.</p><h2 id=termination-conditions>Termination Conditions</h2><h3 id=maximum-iterations>Maximum Iterations</h3><p>\begin{equation}
k > k_{\max }
\end{equation}</p><p>termination condition for those on a deadline</p><h3 id=absolute-improvement>Absolute Improvement</h3><p>\begin{equation}
|f(x_{t}) - f(x_{t+1})| &lt; \epsilon
\end{equation}</p><h3 id=relative-improvement>Relative Improvement</h3><p>\begin{equation}
f(x_{t}) - f(x_{t+1}) &lt; \epsilon | f(x)|
\end{equation}</p><p>Some range of acceptability.</p><h3 id=gradient>Gradient</h3><p>\begin{equation}
|\nabla f(x_{t})| &lt; \epsilon
\end{equation}</p><h2 id=first-order-methods>First-Order Methods</h2><h3 id=gradient-descent--kbhlogistic-regression-dot-md><a href=/posts/kbhlogistic_regression/#gradient-descent>gradient descent</a></h3><p>see <a href=/posts/kbhlogistic_regression/#gradient-descent>gradient descent</a></p><p>\begin{equation}
\bold{d} = \nabla f(x)
\end{equation}</p><h3 id=conjugate-gradient>Conjugate Gradient</h3><p>We optimize the function as if its a gradratic function:</p><p>\begin{equation}
\min_{x} f(x) = \frac{1}{2} \bold{x}^{\top} \bold{A}\bold{x} + \bold{b}^{\top} \bold{x} + c
\end{equation}</p><p>where \(A\) is a positive, definite matrix. Under this assumption, we consider that this function would behave like a bowl.</p><p>We can then formulate:</p><p>\begin{equation}
\bold{d}_{t+1} = -\nabla_{t+1} f + \beta \bold{d}_{t}
\end{equation}</p><p>where \(\bold{d}_{t+1}\) is the step direction we are going to use at <strong><strong>t+2</strong></strong>!! So we are essentially averaging the direction from two steps before.</p><p>We usually set \(\beta\) to be the <strong>Fletcher-Reeves</strong> or <strong>Polak-Ribere</strong> approaches.</p><p>All descent direction are <a href=#mutually-conjugate>Mutually Conjugate</a>.</p><h4 id=mutually-conjugate>Mutually Conjugate</h4><p>if \(x_{i} \neq x_{j}\) are <a href=#mutually-conjugate>Mutually Conjugate</a>, we have:</p><p>\begin{equation}
x_{i} A x_{j} = 0
\end{equation}</p><h3 id=momentum>Momentum</h3><p>We descent by calculating a &ldquo;position&rdquo; and a &ldquo;velocity&rdquo;</p><p>\begin{equation}
v_{t+1} = \beta v_{t} - \alpha \nabla_{x_{t}} f
\end{equation}</p><p>\begin{equation}
x_{t+1} = x_{t} + v_{t+1}
\end{equation}</p><p>if \(\beta\), the momentum is set to \(0\), we just get normal <a href=/posts/kbhlogistic_regression/#gradient-descent>gradient descent</a>. If there is a positive \(\beta\), your update vector will take on some of the previous update direction values.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>