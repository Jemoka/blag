<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS242 NOV122024</title>
<meta name=description content="Haskell
functional
We can express lambda calculi
\begin{equation}
f = \lambda x . x \qty(\lambda y . y)
\end{equation}
def f = \x -> x (\y -> y)
This is currently polymorphic
Haskell primer
pairs!
dup' :: a -> (a,a)
dup' x = (x,x)
arrows here are right associative
pattern match
fst :: (a,b) -> a
fst (x, _) = x
fst (x, _) = x
underscore has special meaning
lists!
a list (cons)
1 : 2
nil
[]
we can also write
[1,2]
ADTs
data IntList = IntCons Int IntList | IntNil
btw; you can also use `backticks` to infix something, so to construct something you can write"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS242 NOV122024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#haskell>Haskell</a><ul><li><a href=#functional>functional</a></li><li><a href=#haskell-primer>Haskell primer</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=haskell>Haskell</h2><h3 id=functional>functional</h3><p>We can express lambda calculi</p><p>\begin{equation}
f = \lambda x . x \qty(\lambda y . y)
\end{equation}</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75af00>def</span> <span style=color:#111>f</span> <span style=color:#f92672>=</span> <span style=color:#75af00>\</span><span style=color:#111>x</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>x</span> <span style=color:#111>(</span><span style=color:#75af00>\</span><span style=color:#111>y</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>y</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>This is currently polymorphic</p><h3 id=haskell-primer>Haskell primer</h3><h4 id=pairs>pairs!</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75af00>dup&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#75af00>dup&#39;</span> <span style=color:#111>x</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>arrows here are right associative</p><h4 id=pattern-match>pattern match</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75af00>fst</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span>
</span></span><span style=display:flex><span><span style=color:#75af00>fst</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#111>,</span> <span style=color:#00a8c8>_</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span>
</span></span><span style=display:flex><span><span style=color:#75af00>fst</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#111>,</span> <span style=color:#00a8c8>_</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span>
</span></span></code></pre></div><p>underscore has special meaning</p><h4 id=lists>lists!</h4><p>a list (cons)</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#00a8c8>:</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>nil</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>[]</span>
</span></span></code></pre></div><p>we can also write</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#111>[</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#ae81ff>2</span><span style=color:#111>]</span>
</span></span></code></pre></div><h4 id=adts>ADTs</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>data</span> <span style=color:#00a8c8>IntList</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>IntCons</span> <span style=color:#00a8c8>Int</span> <span style=color:#00a8c8>IntList</span> <span style=color:#f92672>|</span> <span style=color:#00a8c8>IntNil</span>
</span></span></code></pre></div><p>btw; you can also use <code>`backticks`</code> to infix something, so to construct something you can write</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#ae81ff>12</span> <span style=color:#111>`</span><span style=color:#00a8c8>IntCons</span><span style=color:#111>`</span> <span style=color:#00a8c8>IntNil</span>
</span></span></code></pre></div><h4 id=generic-adts>Generic ADTs</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>data</span> <span style=color:#00a8c8>List</span> <span style=color:#111>a</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>Cons</span> <span style=color:#111>a</span> <span style=color:#111>(</span><span style=color:#00a8c8>List</span> <span style=color:#111>a</span><span style=color:#111>)</span> <span style=color:#f92672>|</span> <span style=color:#00a8c8>Nil</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75af00>l</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>List</span> <span style=color:#00a8c8>String</span>
</span></span></code></pre></div><h4 id=dot-operator>dot operator</h4><p>You can compose functions together&mdash;</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75af00>fn</span> <span style=color:#f92672>=</span>  <span style=color:#111>f1</span> <span style=color:#f92672>.</span> <span style=color:#111>f2</span> <span style=color:#f92672>.</span> <span style=color:#111>f3</span>
</span></span></code></pre></div><h4 id=lazy-semantics-normal-order--kbhcombinator-calculus-dot-md>lazy semantics / <a href=/posts/kbhcombinator_calculus/#normal-order>normal order</a></h4><p>Haskell is a <a href=/posts/kbhcombinator_calculus/#normal-order>normal order</a> language (&mldr;caveats, but basically). This makes side-effects (i.e. a case where the return value isn&rsquo;t used) is hard because side effects don&rsquo;t actually use the return value so it will never be evaluated.</p><p>Some solutions&mldr;</p><ul><li><p>&ldquo;impure&rdquo; languages</p><p>Don&rsquo;t evaluate normal order, and then have side effects directly.</p><ul><li>OCaml</li><li>Scala</li><li>F#</li></ul><p>this makes side effects easy but prevents normal order evaluation</p></li></ul><h4 id=monads>monads</h4><p>notice that you can have monads encoded through ADTs</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>data</span> <span style=color:#00a8c8>State</span> <span style=color:#111>s</span> <span style=color:#111>a</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>State</span> <span style=color:#111>(</span><span style=color:#111>s</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>(</span><span style=color:#111>s</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>))</span>
</span></span></code></pre></div><p>whereby the <code>State</code> monad takes an old state in, and some new state and return value. But, we now have to write state and bind for each possible monad. So, we can abstract away by wrapping stuff in a monad instance.</p><p>To implement: typeclasses!!</p><p>A monad is defined already as&mdash;</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#00a8c8>Monad</span> <span style=color:#111>m</span> <span style=color:#00a8c8>where</span>
</span></span><span style=display:flex><span>  <span style=color:#111>return</span> <span style=color:#f92672>::</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#111>a</span>
</span></span><span style=display:flex><span>  <span style=color:#111>bind</span> <span style=color:#f92672>::</span> <span style=color:#111>m</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#111>b</span>
</span></span></code></pre></div><p>we can inherit this type class</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>instance</span> <span style=color:#00a8c8>Monad</span> <span style=color:#111>(</span><span style=color:#00a8c8>State</span> <span style=color:#111>s</span><span style=color:#111>)</span> <span style=color:#00a8c8>where</span>
</span></span><span style=display:flex><span>  <span style=color:#111>return</span> <span style=color:#f92672>=</span> <span style=color:#111>myReturnFunction</span>
</span></span><span style=display:flex><span>  <span style=color:#111>bind</span> <span style=color:#f92672>=</span> <span style=color:#111>myBindFunction</span>
</span></span></code></pre></div><p>now, we can then define functions that check if stuff inherits this typeclass</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- silly monad thing</span>
</span></span><span style=display:flex><span><span style=color:#75af00>callBind</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Monad</span> <span style=color:#111>m</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>mb</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span>
</span></span><span style=display:flex><span><span style=color:#75af00>callBind</span> <span style=color:#111>f</span> <span style=color:#111>m1</span> <span style=color:#111>m2</span> <span style=color:#f92672>=</span> <span style=color:#111>bind</span> <span style=color:#111>m</span> <span style=color:#111>f</span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>this function is now generic over any monads</p><h4 id=other-typeclasses>other typeclasses</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#00a8c8>Applicative</span> <span style=color:#111>m</span> <span style=color:#00a8c8>where</span>
</span></span><span style=display:flex><span>  <span style=color:#111>pure</span> <span style=color:#f92672>::</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#111>a</span>
</span></span><span style=display:flex><span>  <span style=color:#111>app</span> <span style=color:#f92672>::</span> <span style=color:#111>m</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>m</span> <span style=color:#111>b</span>
</span></span></code></pre></div><p>so you write</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>