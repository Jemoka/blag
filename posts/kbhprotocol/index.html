<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>protocol</title>
<meta name=description content="a protocol for a function \(f\) is a pair of functions \(A,B:\qty {0,1}^{*} \times \qty {0,1}* \to [0,1,STOP]\) whereby:

on input \((x,y)\), we initialize round counter \(r=0\), and initial (empty) message \(b_0 = \epsilon\)
while \(b_{r} \neq STOP\)

\(r++\)
if \(r\) is odd, then Alice sends \(b_{r} = A\qty(x, b_1 \cdots b_{r-1})\)
else Bob sends \(b_{r} = B\qty(y, b_{1} &mldr; b_{r-1})\)


our function output \(b_{r-1}\), and we call \(r-1\) the number of rounds

protocol cost
the cost of a protocol \(P\) for \(f\) on \(n\) bit strings is:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>protocol</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#protocol-cost>protocol cost</a></li><li><a href=#communication-complexity>Communication Complexity</a><ul><li><a href=#trivial-protocol>trivial protocol</a></li></ul></li><li><a href=#examples>examples</a><ul><li><a href=#parity>parity</a></li><li><a href=#majority>majority</a></li><li><a href=#equals>equals</a></li></ul></li><li><a href=#protocol--kbhprotocol-dot-md--s-dfa--kbhdeterministic-finite-automata-dot-md--streaming-algorithms--kbhstreaming-algorithms-dot-md--communication-complexity--org4ac384b><a href=HAHAHUGOSHORTCODE1093s1HBHB>protocol</a>s, <a href=HAHAHUGOSHORTCODE1093s2HBHB>DFA</a>, <a href=HAHAHUGOSHORTCODE1093s3HBHB>Streaming Algorithms</a>, <a href=#communication-complexity>Communication Complexity</a></a><ul><li><a href=#bounded-communication-complexity--org4ac384b>bounded <a href=#communication-complexity>Communication Complexity</a></a></li></ul></li></ul></nav></aside><main><article><div><p>a <a href=/posts/kbhprotocol/>protocol</a> for a function \(f\) is a pair of functions \(A,B:\qty {0,1}^{*} \times \qty {0,1}* \to [0,1,STOP]\) whereby:</p><ul><li>on input \((x,y)\), we initialize round counter \(r=0\), and initial (empty) message \(b_0 = \epsilon\)</li><li>while \(b_{r} \neq STOP\)<ul><li>\(r++\)</li><li>if \(r\) is odd, then Alice sends \(b_{r} = A\qty(x, b_1 \cdots b_{r-1})\)</li><li>else Bob sends \(b_{r} = B\qty(y, b_{1} &mldr; b_{r-1})\)</li></ul></li><li>our function output \(b_{r-1}\), and we call \(r-1\) the number of rounds</li></ul><h2 id=protocol-cost>protocol cost</h2><p>the cost of a protocol \(P\) for \(f\) on \(n\) bit strings is:</p><p>\begin{equation}
\max_{x,y \in \qty {0,1}^{n}} \text{number of rounds in P required to compute $f(x,y)$}
\end{equation}</p><p>i.e: what is the input that could make running this protocol the longest? (remember we call \(r-1\) the number of rounds)</p><h2 id=communication-complexity>Communication Complexity</h2><p>the <a href=#communication-complexity>Communication Complexity</a> of \(f\) on \(n\) bit strings is the minimum <a href=#protocol-cost>protocol cost</a> over all possible protocols for \(f\) on n bit strings.</p><p>the range of communication complexity is $[2, 2n]$&mdash;the former because each party has to say something to communicate, the latter because&mldr;</p><h3 id=trivial-protocol>trivial protocol</h3><p>there is always a &ldquo;trivial&rdquo; protocol: Alice can always just send her the bits of her \(x\) in the odd rounds, and Bob can send his bits of his \(y\) in the even rounds, and after \(2n\) we just communicated the input entirely and tada the end and they can compute \(f(x,y)\) and be done.</p><h2 id=examples>examples</h2><h3 id=parity>parity</h3><p>Consider:</p><p>\begin{equation}
PARITY(x,y) = \qty(\sum_{i}^{}x_{i} + \sum_{i}^{} y_{i}) \ \text{mod}\ 2
\end{equation}</p><ul><li>Alice sends \(b_1 = \qty(\sum_{i}^{}x_{i} \ \text{mod}\ 2)\)</li><li>Bob send \(b_2 = \qty(b_{1} + \sum_{i}^{}y_{i}\ \text{mod}\ 2)\)</li></ul><p>the end! because mods can distribute to each part of the sum. hence, the <a href=#communication-complexity>Communication Complexity</a> of PARITY is 2&mdash;this is a minimal communication (2 round communication)</p><h3 id=majority>majority</h3><p>Consider:</p><p>what is the most frequent bit in \(xy\)?</p><ul><li>Alice sends \(N_{x}\), the number of \(1\) in \(x\)</li><li>Bob computes \(N_{y}\), the number of \(1\) in \(y\)<ul><li>Bob sends \(1\) IFF \(N_{x}+N_{y}\) is greater than \(\frac{\qty(|x|+|y|)}{2} = n\)</li></ul></li></ul><p>hence, we need to send at least \(\log_{2}(n)\) bits where Alice is sending over the number of $1$s.</p><h3 id=equals>equals</h3><p>\begin{equation}
\text{EQUALS}(x,y) = 1 \text{ IFF } x =y
\end{equation}</p><h4 id=complexity-of-equals>complexity of EQUALS</h4><p>The communication complexity of EQUALS is \(\theta (n)\). Every protocol for EQUALS needs \(\geq n\) bits of communication. This also results in that every streaming algorithm for EQUALS needs \(cn\) bits of memory, for some constant \(c>0\).</p><p>Let&rsquo;s define the <em>communication pattern</em> to be the sequence of bits that are set. Assume for the sake of contradiction that there is a protocol for which communicating EQUALS only takes \(\leq n-1\) bits.</p><p>That means that there&rsquo;s only \(2^{n-1}\) possible communication patterns to communicate this protocol. By pigeonhole, there&rsquo;s something of length \(n\) exactly for which on \((x,x)\) and \((y,y)\) uses the same communication pattern when \(x \neq y\) (because there are \(2^{n}\) such pairs \((x,x)\), so it should produce correspondingly \(2^{n}\) such patterns).</p><p>Notice! This means that the communication pattern of \((x,y)\) is also going to be the same (we induce this by noticing that each turn, if the pattern is the same, each party is going to see the same inputs and will return the same outputs.)</p><p>This is contradiction because the protocol outputs the same bit for both \((y,y)\) and \((x,y)\), which is not good.</p><ul><li><p>getting better results with randomized protocols</p><p>general idea: after applying some error correcting code, a single-bit error will result in errors in many-many bits; we then can send just a few random bits and then be able to be fairly sure that the underlying strings are roughly the same.</p><ol><li>Alice picks a random prime number</li><li>She sends \(p\) to Bob, and sends \(x \ \text{mod}\ p\) to bob \(O(\log n)\) bits to send</li><li>bob checks whether \(y = x\ \text{mod}\ p\)</li></ol></li></ul><h2 id=protocol--kbhprotocol-dot-md--s-dfa--kbhdeterministic-finite-automata-dot-md--streaming-algorithms--kbhstreaming-algorithms-dot-md--communication-complexity--org4ac384b><a href=/posts/kbhprotocol/>protocol</a>s, <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>, <a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a>, <a href=#communication-complexity>Communication Complexity</a></h2><p>Let \(L \subseteq \qty{0,1}^{*}\), let \(f_{L}: \qty {0,1}^{*} \times \qty {0,1}^{*} \to \qty {0,1}\)</p><p>for \(x,y\) with \(|x| = |y|\) written as:</p><p>\begin{equation}
f_{L}(x,y) = 1 \Leftrightarrow xy \in L
\end{equation}</p><p>for instance, if we had a language:</p><p>\begin{equation}
L = \qty { x x \mid x \in {0,1}^{*}}
\end{equation}</p><p>this is equal to the function EQUALS above.</p><h3 id=bounded-communication-complexity--org4ac384b>bounded <a href=#communication-complexity>Communication Complexity</a></h3><p>if \(L\) has a <a href=/posts/kbhstreaming_algorithms/>Streaming Algorithms</a> using \(\leq s\) bits of space, then the communication complexity of \(f_{L}\) is at most \(O(s)\).</p><h4 id=proof>Proof</h4><p>Alice can run the streaming algorithm \(A\) on \(x\); Alice sends the memory of \(A\) after doing that: this uses \(s\) bits of space. And then Bob loads the memory, and runs it from there.</p><p>If accept, then return a \(1\); otherwise, no.</p><h4 id=corollary>Corollary</h4><p>For every regular language, the communication complexity of \(f_{L}\) is \(O(1)\). Because we can just send our state ID over.</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>