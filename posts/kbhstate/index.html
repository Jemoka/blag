<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>state</title><meta name=description content="Lambda Calculus with state:
\begin{equation}
e \to (x | \lambda x . e | e e | i | \text{new} | {!e} | e := e)
\end{equation}
where:

\(new\) allocate a new memory location \(x\) and return pointer (initialize \(x\) to \(0\))
\(!e\) deref a pointer
\(e := e\), which is assigning the pointee of the memory location at the first argument to the second argument

new
\begin{equation}
\frac{l \not \in dom(S)}{E,S \vdash \text{new} \to  l, S[l=0]}
\end{equation}"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>state</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#new>new</a></li><li><a href=#dereference>dereference</a></li><li><a href=#assignment>assignment</a></li><li><a href=#store>store</a><ul><li><a href=#some-observations>some observations</a></li><li><a href=#semantics-is-very-costly>semantics is very costly</a></li></ul></li></ul></nav></aside><main><article><div><p><a href=/posts/kbhsu_cs242_oct032024/#lambda-calculus>Lambda Calculus</a> with state:</p><p>\begin{equation}
e \to (x | \lambda x . e | e e | i | \text{new} | {!e} | e := e)
\end{equation}</p><p>where:</p><ul><li>\(new\) allocate a new memory location \(x\) and return pointer (initialize \(x\) to \(0\))</li><li>\(!e\) deref a pointer</li><li>\(e := e\), which is assigning the pointee of the memory location at the first argument to the second argument</li></ul><h2 id=new>new</h2><p>\begin{equation}
\frac{l \not \in dom(S)}{E,S \vdash \text{new} \to l, S[l=0]}
\end{equation}</p><p>that is, we need to return to ourselves a new place in memory</p><h2 id=dereference>dereference</h2><p>\begin{equation}
\frac{E, S_0 \vdash e \to l, S_1}{E, S_0 \vdash !e \to S_{1}(l), S_1}
\end{equation}</p><h2 id=assignment>assignment</h2><p>\begin{equation}
\frac{\begin{align}
&amp;E, S_0 \vdash e_1 \to I, S_1 \\
&amp;E, S_1 \vdash e_2 \to v, S_2
\end{align}}{
E, S_0 \vdash e_1 := e_2 \to v, S_2[I=v]}
\end{equation}</p><h2 id=store>store</h2><p>a <em>store</em> is a mapping from memory locations to values&mdash;</p><p>\begin{equation}
S = [l_1 = 1, l_2 = 42]
\end{equation}</p><p>where, \(1\) is stored at location \(l_{1}\), and \(42\) is stored at location \(l_2\)</p><p>importantly! locations are <strong>first class</strong>&mdash;we can return pointers</p><h3 id=some-observations>some observations</h3><ul><li>the store is an extra argument in the environment</li><li>the store is never copied: no evaluation step uses more than one store, and every store is modified at most once</li><li>the state is unstructured; the whole store is passed to every step of the evaluation even if only a part is used</li></ul><h3 id=semantics-is-very-costly>semantics is very costly</h3><ul><li>sequential order of evaluation must be defined (otherwise your state will be inconsistent)</li><li>there are uncontrolled amount of aliasing of names</li><li>unstructured states exposes too much since we only look up a few things at a time</li></ul></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>