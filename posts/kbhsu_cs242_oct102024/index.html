<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS242 OCT102024</title>
<meta name=description content="more on types
Remember: when we say \(e: t\), this means that as we evaluate \(e\), after all reductions we will get a thing of type \(t\).
type checking

start at the leaves, integers and variables
for each one above, match the expression to the type rules

a* type inference

for every distinct lambda variable, we name a new type
then, for function applications, we have then also substitute the output type of the function with a type variable

then, to saturating the constraint, we solve them using:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS242 OCT102024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#type-checking>type checking</a><ul><li><a href=#canonicalization>canonicalization</a></li></ul></li><li><a href=#let-expression>let expression</a></li><li><a href=#polymorphic-types>polymorphic types</a><ul><li><a href=#universally-quantified-types>universally quantified types</a></li><li><a href=#key-idea>key idea</a></li></ul></li></ul></nav></aside><main><article><div><p>more on <a href=/posts/kbhtyping/>type</a>s</p><p>Remember: when we say \(e: t\), this means that as we evaluate \(e\), after all reductions we will get a thing of type \(t\).</p><h2 id=type-checking>type checking</h2><ol><li>start at the leaves, integers and variables</li><li>for each one above, match the expression to the <a href=/posts/kbhtyping/#type-rules>type rules</a></li></ol><p>a* type inference</p><ol><li>for every distinct lambda variable, we name a new type</li><li>then, for function applications, we have then also substitute the output type of the function with a type variable</li></ol><p>then, to saturating the constraint, we solve them using:</p><ul><li>\(t = a \implies a = t\)</li><li>\(a = t_1, a = t_2 \implies a = t_1, a = t_2, t_1=t_2\)</li><li>\(t_1 \to t_2 = t_3 \to t_4 \implies t_1 \to t_2 = t_3 \to t_4 = t_1 = t_3, t_2 =t_4\)</li></ul><p>to then check and infer types</p><ul><li>we want to make sure no functions are int \(x \to y = int\)</li><li>we want to make sure that an equation has no infinite solutions: \(int \to int \to \ldots\)</li></ul><p>we do the first thing by staring at it real hard; we do the second thing by <a href=#canonicalization>canonicalization</a>.</p><h3 id=canonicalization>canonicalization</h3><ul><li>That no equation \(x \to y = int\) is present</li><li>That the equations do not have infinite solutions</li><li>Otherwise the program is ill-typed</li></ul><p>we want every equivalent type to be represented by one thing.</p><ul><li>\(C(S, int) = int\)</li><li>\(C(S, t\to t&rsquo;) = C(S,t) \to C(S, t&rsquo;)\)</li><li>\(C(S, a) = C(S, t)\) if \(a = t \in S\), and \(t\) is not a type variable</li><li>\(C(S, a) = C(S, b)\) if \(a = b \in S\), and \(a &lt; b\) (for some oner)</li><li>\(C(S, a) = a\), otherwise</li></ul><p>This could go into an infinite loop&mdash;whenever you are canonicalizing something and you got the same expression twice you need to stop because you have an infinite loop. You can do this by keeping what you have seen of variables around.</p><h2 id=let-expression>let expression</h2><p>god we finally have variables.</p><p>\begin{equation}
let\ f = \lambda x.e\text{ in } e'
\end{equation}</p><p>is equivalent to</p><p>\begin{equation}
(\lambda f . e&rsquo;) \lambda x .e
\end{equation}</p><h2 id=polymorphic-types>polymorphic types</h2><h3 id=universally-quantified-types>universally quantified types</h3><p>types are allowed to be what they were before</p><p>\begin{equation}
t \to a | t \to t | int
\end{equation}</p><p>but then we also have some kind of type qualifier</p><p>\begin{equation}
o \to \forall a . o | t
\end{equation}</p><h3 id=key-idea>key idea</h3><p>&ldquo;if we prove that \(e :t\), and the proof doesn&rsquo;t rely on assumptions about \(\alpha\), then we have also proven \(e: \forall a. t\)&rdquo;</p></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>