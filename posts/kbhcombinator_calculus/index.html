<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Combinator Calculus</title>
<meta name=description content="combinator is a variable free programming language; it is a turing complete computational formalism.

this is a language of functions
it is extremely minimalist

clear away the complexity of a real language
allows for illustration of ideas



definition
Terms of SKI calculus are the smallest sets such that \(S, K, I\) are terms; and if \(x, y\) are terms, then \(x y\) is a term.
key fact: terms are trees, not strings&mdash;in absence of parans, association is to the left: \(S x y z \to (((Sx) y) z)\)"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>Combinator Calculus</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#definition>definition</a><ul><li><a href=#rewrite-system>rewrite system</a></li><li><a href=#cfg>CFG</a></li></ul></li><li><a href=#abstraction-algorithm>abstraction algorithm</a></li><li><a href=#programming-with-sii-calculus>programming with SII calculus</a><ul><li><a href=#general-recursion>general recursion</a></li><li><a href=#conditionals>conditionals</a></li><li><a href=#pair>pair</a></li><li><a href=#natural-numbers>natural numbers</a></li></ul></li><li><a href=#examples>Examples</a><ul><li><a href=#factorial>factorial</a></li></ul></li></ul></nav></aside><main><article><div><p>combinator is a variable free programming language; it is a turing complete computational formalism.</p><ul><li>this is a language of functions</li><li>it is extremely minimalist<ul><li>clear away the complexity of a real language</li><li>allows for illustration of ideas</li></ul></li></ul><h2 id=definition>definition</h2><p>Terms of SKI calculus are the smallest sets such that \(S, K, I\) are terms; and if \(x, y\) are terms, then \(x y\) is a term.</p><p><strong>key fact</strong>: terms are <em>trees</em>, not <em>strings</em>&mdash;in absence of parans, association is to the left: \(S x y z \to (((Sx) y) z)\)</p><h3 id=rewrite-system>rewrite system</h3><ul><li>\(I x \to x\), identity function</li><li>\(K x y \to x\), constant functions</li><li>\(S x y z \to (xz) (yz)\), generalized function application</li></ul><h4 id=constant-formating-function-k>Constant formating function \(K\)</h4><p>\(K\) semantics:</p><ul><li>\(K\), pass; doesn&rsquo;t cause computation</li><li>\(Kx\), partial function application; doesn&rsquo;t cause comptation</li><li>\(K x y \to x\), only executes when it has two arguments</li><li>\(K x y z \to x z\), again a partial application</li></ul><p>this is a constant-forming function, meaning apply \(x\) to \(K\) will give you the constant \(x\), no mater what else ouo do to it</p><h4 id=function-application-s>function application \(S\)</h4><p>this allows you to&mdash;</p><ul><li>have fnction calls</li><li>reuse values</li></ul><p>\begin{equation}
S x y z \to (xz) (yz)
\end{equation}</p><h3 id=cfg>CFG</h3><ul><li>\(Expr \to S\)</li><li>\(Expr \to K\)</li><li>\(Expr \to I\)</li><li>\(Expr \to Expr Expr\)</li><li>\(Expr \to (Expr)\)</li><li>\(Expr \to S | K | I | Expr Expr | (Expr)\)</li></ul><p>\(Expr\) is a non terminal; CFG application is done when we have no more \(Expr\) left.</p><h2 id=abstraction-algorithm>abstraction algorithm</h2><p>the <a href=#abstraction-algorithm>abstraction algorithm</a> is a system for writing out combinators.</p><ol><li>start with a function equation using the variables we want \(swap\ x y \to y x\)</li><li>then, use an <strong>abstraction algorithm</strong> \(A\) which eliminates variables on RHS and replace them with \(S, K, I\)</li></ol><p>key: <strong>run this algorithm in the currying order; so if we have $f x y = &mldr;$, run \(A\) on \(y\) first, then \(x\)</strong></p><hr><p>\(A(b,a)\) is an algorithm that drops <strong>a</strong> from the expression <strong>b</strong>. consider: \(f x = E\), we want a <strong>combinator that does</strong> \(A(E,x)\) which implements \(f\).</p><ul><li>\(A(x,x) = I\)</li><li>\(A (E, x) = K E\)</li><li>\(A ( E_1 E_2, x) = S A(E_1, x) A (E_2, x)\)</li></ul><p>(non standard) Alex&rsquo;s special abstraction rules</p><p>define:</p><ul><li><p>\(c_1 x y z \to x ( y z)\)</p></li><li><p>\(c_2 x y z = (x z) y\)</p></li><li><p>\(A(E_1 E_2, x) = c_1 E_1 A (E_2, x)\), if \(x\) doesn&rsquo;t appear in \(E_1\)</p></li><li><p>\(A(E_1 E_2, x) = c_2 A (E_1, x) E_2\) , if \(x\) doesn&rsquo;t appear in \(E_2\)</p></li><li><p>\(A(E_1 E_2, x) = S A(E_1, x) A(E_2, x)\), otherwise</p></li></ul><hr><p>For each variable on the right time, we want to apply the abstraction algorithm \(A\) once: an example with \(swap\ x y \to y x\)</p><ol><li>\(yx = A(y x, y) = S A (y,y) A(x,y) = SI (K x)\)</li><li>\(SI (K x) = A(SI (K x), x)\) and so on</li></ol><h2 id=programming-with-sii-calculus>programming with SII calculus</h2><h3 id=general-recursion>general recursion</h3><p>Notice that \((SII)(SII) \to I (SII) I(SII) \to (SII) (SII)\) is a basic infinite loop. suppose we want to keep applying \(f\) to something.</p><p>Let us define \(x = S(Kf)(SII)\).</p><p>So now:</p><p>\begin{equation}
S II x \to^{*} x x \to^{*} f (x x) \to^{*} f(f(x x)) \dots
\end{equation}</p><p><strong>general tip</strong>: notice apply \(K\) to things is a good way to get more of that thing. We use that trick in \(x\)</p><h4 id=expanding-one-step>expanding one step</h4><p>\(x x \to S (Kf) (S II ) x \to S (K f) x ( S I I) x\)</p><h3 id=conditionals>conditionals</h3><p>Let&rsquo;s first create some <strong>encoding</strong> (weak &ldquo;ADT&rdquo; without type system) which gives you booleans. Perhaps we can design true and false such that \(T a b \to a\) and \(F a b \to b\).</p><ul><li>\(T = K\)</li><li>\(F = SK\)</li></ul><p>Now, we also need to create our boolean operations:</p><ul><li><strong>not</strong>: \(B F T\) because if \(B\) is true, it will pick the first thing which is a False; otherwise, it will pick the second thing which is a True</li><li><strong>or</strong>: \(B_1 T B_2\) because if \(B_1\) is true, it will give you \(T\), otherwise, it will give you what \(B_2\)</li><li><strong>and</strong>: \(B_1 B_2 F\) because if \(B_1\) is true, we also need \(B_2\) to be true; otherwise, it will give you False</li></ul><p>If statements:</p><ul><li>\(B X Y\), because our boolean <em>is</em> the thing that allows us to choose between branches</li></ul><h3 id=pair>pair</h3><p><strong>pair</strong> is 2-tuples:</p><ul><li>\(pair\ x y\ first = x\)</li><li>\(pair\ x y\ second = y\)</li></ul><p>let us choose</p><ul><li>\(first = T\)</li><li>\(second = F\)</li></ul><figure><img src=/ox-hugo/2024-09-26_10-12-40_screenshot.png></figure><h3 id=natural-numbers>natural numbers</h3><p>natural number \(n\) is a function that applies its first argument \(n\) times to the second arguments, meaning:</p><ul><li>\(0 f x = x\); so \(0 = S K\)</li><li>\(succ\ n f x = f (n f x)\); so \(succ = S(S (K S) K)\)</li></ul><p>some operations</p><ul><li>\(1 = succ\ 0\)</li><li>\(add\ x y = x\ succ\ y\)</li><li>\(mul\ x\ y = x\ (add\ y)\ 0\)</li></ul><p>you will note that this is <a href=#natural-numbers>primitive recursion</a>: the number of times we iterate is <strong>fixed</strong> (or capped, as in <code>break</code>) on entry&mdash;we cannot use control flow to stop recursion.</p><h2 id=examples>Examples</h2><ul><li>\(SK xy \to (K y) (x y) \to y\) &mdash; so the function \(SK\) returns the second argument</li><li>\(K x y \to x\) &mdash; so the function \(K\) returns the first argument</li><li>\(S II X \to (Ix) (Ix) \to x (I x) \to x x\)</li><li>\((SII)(SII) \to I (SII) I(SII) \to (SII) (SII)\) &mdash; infinite loop</li><li><strong>swap</strong>: \(swap\ x y \to y x\) is defined by \(swap = S ( K ( SI)) (S (K K) I)\)</li></ul><h3 id=factorial>factorial</h3><p>Let&rsquo;s write it out first:</p><ul><li>\(fac\ n = fac&rsquo;\ 1\ 1\ n\)</li><li>\(fac&rsquo;\ a\ i\ n = if\ i > n\ then a\ else\ fac&rsquo;\ (a * i) (i + 1) n\)</li></ul><p>[TODO]</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>