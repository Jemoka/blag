<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>CS154 Final Summary</title>
<meta name=description content="Finite Automata
Deterministic Finite Automata, computability (in particular regular languages) and Non-deterministic Finite Automata (i.e. verified guessing)
optimization and Learning DFA
we were then able to characterize hardness with Streaming Algorithm and Communication Complexity
Computability Theory
turing machines, and Oracle Turing Machine, and things that are decidable vs. recognizable
through mapping reductions, we are then able to make decidability and recognizablility claims for many languages
we learned about the hierarchy of hard problems through the notion of SUPERHALT in Oracle Turing Machines
We tied mathematics and computation together, and showed Godel&rsquo;s Theorem about the Limitations of Mathematics"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://bsky.app/profile/jemoka.com class=header-social id=header-twitter><i class="ic fa-brands fa-bluesky"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>CS154 Final Summary</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#finite-automata>Finite Automata</a></li><li><a href=#computability-theory>Computability Theory</a></li><li><a href=#complexity-theory>Complexity Theory</a></li><li><a href=#other-ideas>Other Ideas</a></li></ul></nav></aside><main><article><div><h2 id=finite-automata>Finite Automata</h2><p><a href=/posts/kbhdeterministic_finite_automata/>Deterministic Finite Automata</a>, <a href=/posts/kbhcomputability/>computability</a> (in particular <a href=/posts/kbhregular_language/>regular language</a>s) and <a href=/posts/kbhnondeterministic_finite_automata/>Non-deterministic Finite Automata</a> (i.e. verified guessing)</p><p><a href=/posts/kbhoptimization/>optimization</a> and <a href=/posts/kbhdeterministic_finite_automata/#learning-dfa>Learning DFA</a></p><p>we were then able to characterize hardness with <a href=/posts/kbhstreaming_algorithms/>Streaming Algorithm</a> and <a href=/posts/kbhprotocol/#communication-complexity>Communication Complexity</a></p><h2 id=computability-theory>Computability Theory</h2><p><a href=/posts/kbhturing_machinea/>turing machine</a>s, and <a href=/posts/kbhoracle_reduction/#oracle-turing-machine>Oracle Turing Machine</a>, and things that are <a href=/posts/kbhturing_machinea/#decidable>decidable</a> vs. <a href=/posts/kbhturing_machinea/#recognizable>recognizable</a></p><p>through <a href=/posts/kbhmapping_reduction/>mapping reduction</a>s, we are then able to make <a href=/posts/kbhturing_machinea/#decidable>decidability</a> and <a href=/posts/kbhturing_machinea/#recognizable>recognizablility</a> claims for many languages</p><p>we learned about the hierarchy of hard problems through the notion of <a href=/posts/kbhoracle_reduction/#superhalt>SUPERHALT</a> in <a href=/posts/kbhoracle_reduction/#oracle-turing-machine>Oracle Turing Machine</a>s</p><p>We tied mathematics and computation together, and showed <a href=/posts/kbhmathematics/#limitations-of-mathematics>Godel&rsquo;s Theorem</a> about the <a href=/posts/kbhmathematics/#limitations-of-mathematics>Limitations of Mathematics</a></p><p>We described the notion of information encoding though <a href=/posts/kbhkolomogorov_complexity/>Kolomogorov Complexity</a></p><h2 id=complexity-theory>Complexity Theory</h2><p>We described <a href=/posts/kbhcomputational_complexity_theory/#time-complexity>Time Complexity</a>, <a href=/posts/kbhp_vs_np/>P vs. NP</a>, and <a href=/posts/kbhnp_complete/>NP-Completeness</a>; nondeterminism came back fully. We then described <a href=/posts/kbhnon_deterministic_turing_machines/#boolean-formula-satisfiability>SAT</a> and <a href=/posts/kbhnon_deterministic_turing_machines/#3cnf-formula>3SAT</a>, which were <a href=/posts/kbhnp_complete/>NP-Complete</a></p><p>We then using <a href=/posts/kbhmapping_reduction/#polynomial-time-mapping-reduction>polynomial time mapping reduction</a> to come up with <a href=/posts/kbhnp_complete/#many-many-np-complete-things>many, many NP-Complete things</a>, and saw a hierarchy of harder problems through the idea of <a href=/posts/kbhoracle_polynomial_time/>Oracle Polynomial Time</a> and \(NP^{NP^{{NP}^{\dots}}}\)</p><h2 id=other-ideas>Other Ideas</h2><ul><li>if you assume you can&rsquo;t factor (i.e. that factoring is super hard), for instance, you made a <strong>one-way function</strong>; this means&mldr;<ul><li>could get random instances in SAT which are hard</li><li>zero-knowledge proofs, because you can check the factor but not do the factoring</li><li>you could deterministically increase entropy: &ldquo;randomness is weak&rdquo;</li></ul></li></ul></div></article></main><footer><p id=footer>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>