<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>AML: REINFORCE(ment learning)</title>
<meta name=description content="Woof. As I begin to write this I should add that this unit is going to be conceptually dense. Though we are teaching one particular algorithm (incidentally, named, REINFORCE), the world of reinforcement learning is build by one, if not many, very advanced treatments in maths.
So if anything, I would focus on getting the conceptual flavor of how these problems are formulated and discuses. If you can be along for the mathematical and algorithmic journey, then even better &mdash; but by no means required or expected&mldr; There&rsquo;s still lots for all of us to learn together."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>AML: REINFORCE(ment learning)</h1><span class=tagbox><span class=tag onclick='window.location.href="/tags/writing"'><span class=hash>#</span>
<span class=tagname>writing</span>
</span><span class=tag onclick='window.location.href="/tags/aml"'><span class=hash>#</span>
<span class=tagname>aml</span></span></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#the-environment-agent-state-action-and-policy>The Environment: Agent, State, Action, and Policy</a></li><li><a href=#reward>Reward</a></li><li><a href=#cumulative-discounted-reward>Cumulative Discounted Reward</a></li><li><a href=#policy-gradient-theorem>Policy Gradient Theorem</a></li><li><a href=#reinforce>REINFORCE</a></li><li><a href=#next-steps>Next Steps</a></li></ul></nav></aside><main><article><div><p>Woof. As I begin to write this I should add that <strong>this unit is going to be conceptually dense</strong>. Though we are teaching one particular algorithm (incidentally, named, REINFORCE), the world of reinforcement learning is build by one, if not many, very advanced treatments in maths.</p><p>So if anything, I would focus on getting the conceptual flavor of how these problems are formulated and discuses. If you can be along for the mathematical and algorithmic journey, then even better &mdash; but by no means required or expected&mldr; There&rsquo;s still lots for all of us to learn together.</p><p>Speaking of college level classes, I <em>loved</em> the detailed and accessible overview of Reinforcement Learning methods by Professors Charles Isbell and Michael Littlman from Georgia Tech CoC. If you find yourself gravitating towards the topic of this unit, go check them out:</p><p><a href=https://omscs.gatech.edu/cs-7642-reinforcement-learning-course-videos>https://omscs.gatech.edu/cs-7642-reinforcement-learning-course-videos</a></p><p>Ok. Let&rsquo;s dive in.</p><h2 id=motivation>Motivation</h2><p>We are used to a clear, <strong>differentiable</strong> loss function. One particular exercise in class we do a lot is to shout out a problem, and think about its loss function:</p><ul><li>&ldquo;classifying Pokemon!&rdquo; &mldr; &ldquo;cross entropy!&rdquo;</li><li>&ldquo;generating stock price!&rdquo; &mldr; &ldquo;MSE!&rdquo;</li><li>&ldquo;making pictures of rice!&rdquo; &mldr; &ldquo;GAN non-saturating loss!&rdquo;</li></ul><p>and so on. Regardless of the classification/regression difference, you will note that these functions are all of the shape:</p><p>\begin{align}
&amp;f(\hat{y}, y) = \text{single float value}
\end{align}</p><p>Meaning, it takes <strong>two vectors</strong>&mdash;the <em>output</em> (&ldquo;prediction&rdquo;, \(\hat{y}\)) of the network, and the <em>desired output</em> (&ldquo;target&rdquo;, \(y\)) in your training data, and produces (sometimes with much mathematical gymnastics) a single scalar value representing which we try to optimize to be lower.</p><p>Note that, regardless of <strong>supervised learning</strong> (like Pokemon classification; we have input, desired targets, and actual output) or <strong>unsupervised learning</strong> (like GAN rice generation; we have only the desired targets and actual output), we <em>have the desired targets</em> in hand. We <em>know</em> what the model is supposed to do (i.e. have many examples of correct behavior), and are just teaching the model to do so one way or other.</p><p>But what if&mldr;. we <em>don&rsquo;t</em> know the correct behavior of the model? Can you brainstorm some tasks that would very well might want to automate using ML, but can&rsquo;t provide precise labels for the desired action?</p><p>&mldr;</p><p>Take, for instance, the task of <a href=https://gymnasium.farama.org/environments/mujoco/humanoid_standup/>teaching this poor stick figure how to stand up</a>:</p><figure><img src=/ox-hugo/2023-04-30_12-37-54_screenshot.png alt="Figure 1: aw so sad"><figcaption><p><span class=figure-number>Figure 1: </span>aw so sad</p></figcaption></figure><p>you are given a list of forces currently hitting the figure, and you are to produce a list of forces the figure&rsquo;s limbs should produce.</p><p>Of course you can&rsquo;t know precisely the labels at every given moment: there are no &ldquo;best&rdquo; or, arguably, even a &ldquo;correct&rdquo; strategy for standing the figure up. There&rsquo;s no labels which you can use to even begin to approach this task!</p><p>What to do?</p><p><strong>In come Reinforcement Learning (RL)</strong></p><p>Ok, this is where the math will begin. I encourage you to take a piece of paper and start writing down each symbol we define together, and refer to that piece of paper copiously to understand the expressions.</p><p>If you want to learn this more, the conceptual basis we are working with is called <strong>policy gradient</strong>, specifically the <strong>REINFORCE</strong> algorithm. This is <em>not even close</em> to being the only way to approach the Reinforcement Learning task; but its one fairly interesting and successful approach.</p><h2 id=the-environment-agent-state-action-and-policy>The Environment: Agent, State, Action, and Policy</h2><p>Three variables underlie the basics of <strong>Reinforcement Learning</strong>:</p><ul><li><strong>state</strong> \(s_{t}\): the &ldquo;situation&rdquo; of the <strong>environment</strong>, what can be &ldquo;observed&rdquo;; for our example above, this looks like the forces on each limb of our humanoid.</li><li><strong>action</strong> \(a\): a certain perturbation one can do to the agent which will influence its <strong>state</strong>; for our example, this looks like moving (&ldquo;translating&rdquo;/&ldquo;applying force on&rdquo;) one or many limbs.</li><li><strong>policy</strong> \(\pi\): the <strong>policy</strong> is a function which takes the <strong>state</strong> as input, and produces a probability distribution (think &ldquo;softmax&rdquo;) over all the <strong>actions</strong> one could choose. We will talk extensively about this shortly.</li><li><strong>agent</strong>: a general term describing the actual thing being controlled; for instance, our humanoid.</li><li><strong>episode</strong>: an entire group of <strong>states</strong>, starting at the beginning and continuing for instance, for a fixed number of <strong>states</strong> or until a certain end is reached (for instance, for the humanoid walking task, when it falls).</li></ul><hr><p>IMPORTANT NOTE: policy is as function \(\pi(s_{t})\), literally a <em>function named pi</em>. It has nothing to do with the ratio between the radius and circumference of a circle. Its <em>just called pi&mldr;</em> Unfortunately, we are working to stick to the language used by current literature, but sometimes their symbol choice is rather deranged.</p><hr><h2 id=reward>Reward</h2><p>In lieu of a loss function, <strong>Reinforcement Learning</strong> is a class of models that learn from a numerical signal called <strong>reward</strong>. The reward function typically looks like this:</p><p>\begin{equation}
r_{t}(s_{t},a_{t}) = \text{single float value}\ (-\infty, +\infty)
\end{equation}</p><p>Instead of calculating the difference between the desired and actual output of the model, the <strong>reward</strong> signal scores <em>how good taking a certain action is</em> in an environment. It takes two vectors as input: the <strong>state</strong> and an <strong>action</strong> on the state, to produce a certain score.</p><p>Unlike what we are used to with the loss, this <strong>reward</strong> value is <em>not</em> differentiable w.r.t. the parameters of the network! The action is a <em>sample</em> from the distribution; so this score can be generated however you&rsquo;d like. Furthermore, unlike what we are used to with <strong>loss</strong>, a <strong>higher</strong> <strong>reward</strong> value means a better action.</p><h2 id=cumulative-discounted-reward>Cumulative Discounted Reward</h2><p>Note again the expression for that reward statement:</p><p>\begin{equation}
r_{t}(s_{t}, a_{t})
\end{equation}</p><p>each of these variables are parameterized by this subscript $t$&mdash;meaning reward is calculated <em>per time!</em> This actually presents us a problem to describe the <em>overall</em> behavior of our agent. Pause and think why this may be.</p><p>&mldr;</p><p>For instance, the act of &ldquo;standing up&rdquo; often require multiple steps; many of which honestly doesn&rsquo;t contribute at all to the act of standing up until many steps later! For instance, the act of propping up one&rsquo;s hands to the ground&mdash;which actually <em>lowers</em> your center of gravity, and hence naively should get a negative reward&mdash;is actually critical in being able to stand up well.</p><p>If we train a model (somehow, ignoring the details for now) to maximize \(r_{t}\), then we will get an <em>instant gratification machine</em>: meaning, its pretty useless for any just a tad-bit complex task!</p><p>To deal with this, we need to introduce the idea of a <strong>trajectory</strong> (\(\tau\)). A <strong>trajectory</strong> is a list of state-action pairs generated by the same exact policy (i.e. no learning at all) just playing a game out to completion&mdash;i.e. until the end of the <strong>episode</strong>.</p><p>That is:</p><p>\begin{equation}
\tau = [(s_{0}, \pi(s_{0})), \dots, (s_{n}, \pi(s_{n}))] = [(s_{0}, a_{0}), \dots, (s_{n}, a_{n})]
\end{equation}</p><p>We then define a new-and-improved reward function \(R_{t}(\tau)\) which models not just <em>how good our policy is right now</em>, but <em>how good WILL our policy be given these set of actions</em>.</p><p>Specifically, at every timestamp:</p><p>\begin{equation}
R_{t}(\tau) = r_{t}(s_{t}, a_{t}) + \gamma r_{t+1}(s_{t+1}, a_{t+1})+ \gamma^{2} r_{t+2}(s_{t+2}, a_{t+2}) + \dots
\end{equation}</p><p>where, \(0 \leq \gamma \leq 1\) is a hyperparameter called a <strong>discount factor</strong> controlling how much more the current reward matters.</p><p>Woof, the math here looks a bit scary; let&rsquo;s break it down. We are defining a function $R<sub>t</sub>(Ï„)$&mdash;taking \(\tau\) as input, meaning this function actually knows all of the model&rsquo;s future behavior as well as current ones; each term of this function \(R\) multiplies \(\gamma\) a certain number of times to the instantaneous reward at that point.</p><p>This function, then, essentially adds up all the <em>future reward taking the current action will eventually lead to</em>&mdash;&ldquo;how much reward does choosing this path afford you&rdquo;&mdash;discounting rewards earned in the future with a certain factor \(\gamma\) because those are subject to change based on your <strong>agent</strong>&rsquo;s future decisions. Things that are more the future gets discounted harder, by \(\gamma^{n}\).</p><p>This expression for \(R_{t}(\tau)\) is called the <strong>cumulative discounted reward</strong>, or &ldquo;the reward&rdquo; for short. When we refer to the reward in the rest of this write-up, this is probably the expression you are looking for.</p><h2 id=policy-gradient-theorem>Policy Gradient Theorem</h2><p>The policy gradient theorem is unfortunately not going to be very well motivated in the time that we have together. If you are curious, the proof, and some more discussion, can be found <a href=https://lilianweng.github.io/posts/2018-04-08-policy-gradient/#proof-of-policy-gradient-theorem>here</a> or in my notes <a href=/posts/kbhpolicy_gradient/>here</a>.</p><p>For now, let&rsquo;s just skip to the result&mldr; The loss function objective \(J\) with which we can use to optimize a neural network, given a set of <em>non-connected</em> <strong>reward</strong> signals and a policy to optimize \(\pi\), is:</p><p>\begin{equation}
-\sum_{t=0} \log \pi_{\theta} (a_{t} | s_{t}) R_{t}(\tau)
\end{equation}</p><p>where, \(\theta\) are the <strong>weights</strong> to <strong>policy</strong> \(\pi\), and the rest are usual symbols defined above.</p><p>Let&rsquo;s break it down.</p><p>The rest of this is a summation over all time of the trajectory; meaning you have to first generate the entire trajectory \(\tau\) first and then add this value per slice:</p><ul><li>\(\pi_{\theta}(a_{t}|s_{t})\): this is the <em>probability</em> (often called &ldquo;confidence&rdquo;) of the model to take action \(a_{t}\) at state \(s_{t}\); for a discrete set of actions (i.e. choosing/classification), we already know how to do this: <code>torch.argmax</code>. The code example below/in class explores how to do this for a continuous sample.</li><li>\(\log \pi_{t}(a_{t}|s_{t})\): we want to take the log of this confidence score the model produced: bigger &ldquo;confident&rdquo; number, smaller magnitude log, smaller error</li><li>\(R_{t}(\tau)\) the <strong>Cumulative Discounted Reward</strong> from that timestamp on, as we discussed before</li></ul><p>The sharp-eyed among you may notice that this function is very similarly shaped as cross-entropy: except you swap out the ground truth \(y\) for the cumulative reward \(R_{t}(\tau)\). Indeed that is the case! In fact, much of the similar motivations apply both functions.</p><h2 id=reinforce>REINFORCE</h2><p>Loss function in hand, its time to actual perform the actual optimization. There&rsquo;s three main steps to actually perform the REINFORCE algorithm optimization:</p><ol><li><strong>Play the game</strong>: generating <em>entire <strong>episode</strong></em> worth of \(s_{t}, a_{t}, r_{t}\) using the same exact unoptimized policy \(\pi\), storing a full trajectory \(\tau\)</li><li><strong>Calculate the reward</strong>: calculate, using the discounting equation above, \(R_{t}\) from each \(r_{t}\). Remember that each \(R_{t}\) is a reward comprised of the current reward, plus \(\gamma\) raised to a certain power to discount the future rewards \(r_{t+n}\).</li><li><strong>Replay and backprop</strong>: Compute the actual error above for each timeframe, backpropegating them all but <em>don&rsquo;t change the weights</em> (i.e. call <code>.backward()</code> but not <code>.step()</code>)</li><li><strong>Change the weights all at once</strong>: call <code>.step()</code> and make our model better!</li></ol><p>As we have no fixed-length data, there are no <strong>epochs</strong> to this setup.; we will instead specify a number of times we want to run the above steps&mdash;meaning we have a number of <strong>episodes</strong> you can tune while training the model.</p><h2 id=next-steps>Next Steps</h2><p>Apart from the bunch of theory here, there still remain a lot of practical questions in how to make all this happen in PyTorch. We hope to discuss this together in class, and explore the wonderful set of tools Gym&mdash;a RL state/reward calculation library&mdash;can do for us!</p><p>To get started on this discussion, here&rsquo;s one implementation of the humanoid-standup task we can be working from: <a href=https://github.com/Jemoka/demo_amlmod4rl/blob/master/main.py>https://github.com/Jemoka/demo_amlmod4rl/blob/master/main.py</a></p></div></article></main><footer><p id=footer>&copy; 2019-2023 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>