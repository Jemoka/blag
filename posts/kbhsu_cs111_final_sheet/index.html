<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS111 Final Sheet</title>
<meta name=description content="FS main challenges naming: how do users name files reliability: surviving OS crashes and hardware failures protection: isolation between users, controlled sharing disk space management: minimize seeks, sharing space (&ldquo;preventing fragmentation&rdquo;) seeks to wait until the platter go under the arm and read.
internal v. external fragmentation internal: a file can be no less than a single block of text. external: no space is available even if the space in aggregate is available main designs contiguous allocation IBM used this?"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS111 Final Sheet</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#fs>FS</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#unix-v6-plus-mli>Unix V6 + MLI</a></li><li><a href=#block-cache>Block Cache</a></li></ul></li><li><a href=#crash-recovery>Crash Recovery</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#goal-design>goal design</a></li><li><a href=#implementation>implementation</a></li></ul></li><li><a href=#mp>MP</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#goal-design>goal design</a></li><li><a href=#implementation>implementation</a></li></ul></li><li><a href=#mt>MT</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#goal-design>goal design</a></li><li><a href=#implementation>implementation</a></li></ul></li><li><a href=#virtual-memory>Virtual Memory</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#goal-design>goal design</a></li><li><a href=#implementation>implementation</a></li></ul></li><li><a href=#multicore-plus-flash>Multicore + Flash</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#goal-design>goal design</a></li><li><a href=#implementation>implementation</a></li></ul></li><li><a href=#ethics>Ethics</a><ul><li><a href=#main-challenges>main challenges</a></li><li><a href=#main-designs>main designs</a></li><li><a href=#goal-design>goal design</a></li><li><a href=#implementation>implementation</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=fs>FS</h2><h3 id=main-challenges>main challenges</h3><ul><li><strong>naming</strong>: how do users name files</li><li><strong>reliability</strong>: surviving OS crashes and hardware failures</li><li><strong>protection</strong>: isolation between users, controlled sharing</li><li><strong>disk space management</strong>: minimize seeks, sharing space (&ldquo;preventing fragmentation&rdquo;)</li></ul><h4 id=seeks>seeks</h4><p>to wait until the platter go under the arm and read.</p><h4 id=internal-v-dot-external-fragmentation>internal v. external fragmentation</h4><ul><li><strong>internal</strong>: a file can be no less than a single block of text.</li><li><strong>external</strong>: no space is available even if the space in aggregate is available</li></ul><h3 id=main-designs>main designs</h3><h4 id=contiguous-allocation>contiguous allocation</h4><p>IBM used this? puts files and meta-data together + implement an explicit free list allocator. <strong>benefit</strong>: simple; <strong>drawback</strong>: 1) external fragmentation 2) hard to grow files</p><h4 id=linked-files>linked files</h4><p>in every block, store the location of the next block; don&rsquo;t store files continuously&mdash;instead, store a pointer to where the next block of the file is. <strong>benefit</strong>: solves fragmentation and file growth; <strong>drawback</strong>: 1) huge seek time 2) random access from the middle is hard (i.e. O(n))</p><h4 id=windows-fat>Windows FAT</h4><p>linked files, but cached the file links in memory when using it. <strong>benefits</strong>: same as linked files, and a bit faster <strong>drawback</strong>: data <em>still</em> fragmented and now you have a whole ass table to deal with! but its at least faster</p><h4 id=file-payload-data>File Payload Data</h4><p>Kind of what we do&mdash;instead of storing file data in order OR using links, store the file BLOCK information contiguously.</p><p><em>multi-level index</em>: store all block numbers for a given file down a tree (EXT2/3, Unix V6, NTFS)</p><h3 id=unix-v6-plus-mli>Unix V6 + MLI</h3><table><thead><tr><th>Sector Size</th><th>Block Size</th><th>Inode Size</th><th>Inodes Per Block</th><th>Address Type</th></tr></thead><tbody><tr><td>512</td><td>512</td><td>32</td><td>16</td><td>Short, 2 bytes</td></tr></tbody></table><h4 id=block>block</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>const</span> <span style=color:#00a8c8>size_t</span> <span style=color:#111>INODE_PER_BLOCK</span> <span style=color:#f92672>=</span> <span style=color:#111>SECTOR_SIZE</span> <span style=color:#f92672>/</span> <span style=color:#00a8c8>sizeof</span><span style=color:#111>(</span><span style=color:#00a8c8>struct</span> <span style=color:#111>inode</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#111>inode</span> <span style=color:#111>inodes</span><span style=color:#111>[</span><span style=color:#111>INODE_PER_BLOCK</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>char</span> <span style=color:#111>buf</span><span style=color:#111>[</span><span style=color:#111>SECTOR_SIZE</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span><span style=color:#75af00>readsector</span><span style=color:#111>(</span><span style=color:#ae81ff>2</span><span style=color:#111>,</span> <span style=color:#f92672>&amp;</span><span style=color:#111>inodes</span><span style=color:#111>);</span> <span style=color:#75715e>// recall this is the first 16 inodes: sec0 is fs info, sec1 is supernode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75af00>printf</span><span style=color:#111>(</span><span style=color:#d88200>&#34;addr: %d</span><span style=color:#8045ff>\n</span><span style=color:#d88200>&#34;</span><span style=color:#111>,</span> <span style=color:#111>inodes</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>].</span><span style=color:#111>i_add</span><span style=color:#111>);</span>
</span></span></code></pre></div><h4 id=ino>ino</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#111>inode</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>i_addr</span><span style=color:#111>[</span><span style=color:#ae81ff>8</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>i_mode</span><span style=color:#111>[</span><span style=color:#ae81ff>8</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>file_size</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><a href=/posts/kbhunix_v6_filesystem/>inode</a>s have two modes</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>if</span> <span style=color:#111>((</span><span style=color:#111>inode</span><span style=color:#111>.</span><span style=color:#111>i_mode</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>ILARG</span><span style=color:#111>)</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#f92672>==</span> <span style=color:#75715e>// node is in &#34;large mode&#34;
</span></span></span></code></pre></div><ul><li>in <strong>small mode</strong>, the <a href=/posts/kbhunix_v6_filesystem/>inode</a> stores in <code>i_addr</code> the block numbers to the data</li><li>in <strong>large mode</strong>, the <a href=/posts/kbhunix_v6_filesystem/>inode</a> stores in the <strong>first seven</strong> numbers in <code>i_addr</code> block numbers to <em>blocks that contain block numbers</em> (512/2 = 256 block numbers, which are chars); the <strong>eighth number</strong> points to <strong>doubly indirect</strong> <em>blocks that contain block numbers that point to other blocks</em></li></ul><p>The <a href=/posts/kbhunix_v6_filesystem/>inode</a> table for each file only contains space to point to \(8\) block. 1 block = 1 sector on Unix v6. <a href=/posts/kbhunix_v6_filesystem/>inode</a>s are usualy 32 bytes big, and 1 block = 1 sector = 512 bytes. usually this packs 16 inodes per block</p><p>in <strong>large mode</strong>, this system can store \((7+256) \cdot (256 \cdot 512) = 34MB\), which is as large as the file system itself, which means we are fine now.</p><ul><li><p>sizing</p><ul><li>small: \(512\) bytes per block, and \(8\) block storable, so \(8 \cdot 512 = 4096\) bytes</li><li>large: \(512\) bytes per block pointed to by i_addr, each containing \(\frac{512}{2} = 256\) block numbers. The first seven in total would therefore address \(256 \times 7 = 1792\) blocks of memory. The last eight would each address \(256 \cdot 256 = 65536\) blocks of memory. In total, that addresses \(1792+65536 = 67328\) blocks of memory. Finally, that means we can address \(67328 \cdot 512 = 34471936\) bytes.</li></ul></li></ul><h4 id=dir>dir</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#111>dirent</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>d_inumber</span><span style=color:#111>;</span> <span style=color:#75715e>// inode number of this file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>char</span> <span style=color:#111>d_name</span><span style=color:#111>[</span><span style=color:#ae81ff>14</span><span style=color:#111>];</span> <span style=color:#75715e>// the name; *NOT NECESSARILY NULL TERMINATED*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>THE NAME MAY NOT BE NULL TERMINATED</strong> to cram max things. You have to use <strong>strncmp</strong></p><p><strong>strcmp/strncmp</strong>: stops comparing after \(n\) characters; &lt;0 if str1 comes before str2 alphabetically; >0 if str1 comes after str2; 0 if equal</p><p>Start at the root directory, <code>/</code>. We want to go to the root directory, and find the entry named <code>/classes/</code>, and then, in that directory, find the file. etc. Traverse recursively. Directory could have metadata.</p><p>A directory is basically just a <strong>file whose payload is a list of <code>dirent</code></strong>.</p><p>The inode tells you whether something is a file or a directory. They can be small or large, as usual. Root directory always have inode number <code>1</code>; <code>0</code> is reserved to NULL.</p><h4 id=file>file</h4><p>Recall that <code>read</code> doesn&rsquo;t read the whole thing. So, we it in parts.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#75af00>copyContents</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>sourceFD</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>destinationFD</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>char</span> <span style=color:#111>buffer</span><span style=color:#111>[</span><span style=color:#111>INCREMENT</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>true</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>ssize_t</span> <span style=color:#111>bytesRead</span> <span style=color:#f92672>=</span> <span style=color:#111>read</span><span style=color:#111>(</span><span style=color:#111>sourceFD</span><span style=color:#111>,</span> <span style=color:#111>buffer</span><span style=color:#111>,</span> <span style=color:#00a8c8>sizeof</span><span style=color:#111>(</span><span style=color:#111>buffer</span><span style=color:#111>));</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>bytesRead</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#00a8c8>break</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>size_t</span> <span style=color:#111>bytesWritten</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>bytesWritten</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>bytesRead</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>ssize_t</span> <span style=color:#111>count</span> <span style=color:#f92672>=</span> <span style=color:#111>write</span><span style=color:#111>(</span><span style=color:#111>destinationFD</span><span style=color:#111>,</span> <span style=color:#111>buffer</span> <span style=color:#f92672>+</span> <span style=color:#111>bytesWritten</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>                                  <span style=color:#111>bytesRead</span> <span style=color:#f92672>-</span> <span style=color:#111>bytesWritten</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>            <span style=color:#111>bytesWritten</span> <span style=color:#f92672>+=</span> <span style=color:#111>count</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#75af00>open</span><span style=color:#111>(</span><span style=color:#00a8c8>const</span> <span style=color:#00a8c8>char</span> <span style=color:#f92672>*</span><span style=color:#111>pathname</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>flags</span><span style=color:#111>);</span>
</span></span></code></pre></div><p>Flags are a bitwise OR operations: you have to open with <code>O_RDONLY</code> (read only), <code>O_WRONLY</code> (write only), or <code>O_RDWR</code> (both read and write). This returns \(-1\) if the reading fails.</p><p>Other flags:</p><ul><li><code>O_TRUNC</code> (truncate file)</li><li><code>O_CREAT</code> (creating a file if not exist), which will require a <code>mode_t mode</code> parameter to set the permission</li><li><code>O_EXCL</code> (file must not exist)</li></ul><h3 id=block-cache>Block Cache</h3><p>We will use part of the main memory to retain recently-accessed disk <strong>blocks</strong>. This is <strong>NOT</strong> at the granularity of individual files.</p><h4 id=least-recently-used--lru--cache>Least Recently Used (LRU) Cache</h4><p>When you insert a new element into the cache, kick out the element on the cache that hasn&rsquo;t been touched in the longest time.</p><h4 id=block-cache-modification>Block Cache Modification</h4><p>we can either <strong>write asap</strong>, or <strong>delay</strong>.</p><p><strong><strong>write asap</strong></strong>: <em>safer</em>: less risk of data loss, written as soon as possible; <em>slow</em>: program must wait to proceed until disk I/O completes</p><p><strong><strong>write delay</strong></strong>: <em>dangerous</em>: may loose data after crash; <em>efficient</em>: memory writes is faster</p><h2 id=crash-recovery>Crash Recovery</h2><h3 id=main-challenges>main challenges</h3><h3 id=main-designs>main designs</h3><h3 id=goal-design>goal design</h3><h3 id=implementation>implementation</h3><h2 id=mp>MP</h2><h3 id=main-challenges>main challenges</h3><h3 id=main-designs>main designs</h3><h3 id=goal-design>goal design</h3><h3 id=implementation>implementation</h3><h2 id=mt>MT</h2><h3 id=main-challenges>main challenges</h3><h3 id=main-designs>main designs</h3><h3 id=goal-design>goal design</h3><h3 id=implementation>implementation</h3><h2 id=virtual-memory>Virtual Memory</h2><h3 id=main-challenges>main challenges</h3><h3 id=main-designs>main designs</h3><h3 id=goal-design>goal design</h3><h3 id=implementation>implementation</h3><h2 id=multicore-plus-flash>Multicore + Flash</h2><h3 id=main-challenges>main challenges</h3><h3 id=main-designs>main designs</h3><h3 id=goal-design>goal design</h3><h3 id=implementation>implementation</h3><h2 id=ethics>Ethics</h2><h3 id=main-challenges>main challenges</h3><h3 id=main-designs>main designs</h3><h3 id=goal-design>goal design</h3><h3 id=implementation>implementation</h3><p>Crash Recovery: tradeoffs, data loss and inconsistency, atomic operations, free list and block cache, fsck, ordered writes, write-ahead logging, transactions, checkpoints, idempotency, durability and consistency</p><p>Multiprocessing: processes, PIDs, fork, execution order, copy on write, waitpid, zombie processes, execvp, pipes and pipe / pipe2, I/O redirection</p><p>Multithreading: processes vs. threads, C++ threads and .join(), thread safety, race conditions, atomicity, critical sections, mutexes, deadlock, busy waiting, condition variables, notify_all, unique_lock, monitor pattern; dining philosophers</p><p>Dispatching / Scheduling: Process control blocks, traps and interrupts, context switching, thread state (running / blocked / ready), I/O-bound and CPU-bound threads, scheduling algorithms, first-come-first-serve, round robin, shortest remaining processing time (SRPT), priority-based scheduling, preemption, interrupts, implementing single-core locks and condition variables</p><p>Virtual memory: single-tasking, process memory, memory sharing goals, load-time relocation, dynamic address translation and MMU, virtual and physical addresses, base and bound, multiple segments, paging, demand paging, page maps, page faults, thrashing, fragmentation, disk swap, page replacement policies, random replacement, FIFO replacement, LRU replacement, clock algorithm, per process vs. global replacement, virtualization.</p><p>Modern technologies: multicore processors (multicore scheduling, work stealing, core affinity, gang scheduling, multicore locks (for multicore locks, just high level ideas about interrupts being insufficient to prevent races, atomic operations, and that busy waiting is necessary)), flash storage (quirks of erase + write operations, wear-out, wear-leveling, flash translation layer high-level idea)</p><p>Ethics and trust: trust and agency, trust by assumption, trust by inference, trust by substitution, agential gullibility, violations of trust, stakeholders, pervasiveness, time.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>