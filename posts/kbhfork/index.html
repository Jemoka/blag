<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>fork</title>
<meta name=description content="fork creates a second process that is an exact clone from the first.
The original process is called the parent, the child process is called the child. The child comes in at the next instruction after fork. This means that fork calls once, returns twice. After fork, the execution order between both processes is completely up to the OS. After fork, we cannot assume execution order.
Fork&rsquo;s return value is different between parent and child:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>fork</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#things-that-are-duplicated>things that are duplicated</a></li><li><a href=#shell>shell</a></li><li><a href=#fork-mechanics>fork mechanics</a></li></ul></nav></aside><main><article><div><p><a href=/posts/kbhfork/>fork</a> creates a second process that is an exact <strong>clone</strong> from the first.</p><p>The original process is called the <strong>parent</strong>, the child process is called the <strong>child</strong>. The <strong>child</strong> comes in at the next instruction after fork. This means that fork <strong>calls once, returns twice</strong>. <strong>After <code>fork</code>, the execution order between both processes is completely up to the OS.</strong> After fork, we cannot assume execution order.</p><p>Fork&rsquo;s <strong>return value</strong> is different between parent and child:</p><ul><li>in parent, fork will return the PID of the child process</li><li>in the child, fork will return \(0\), you can get PID by calling <code>getpid</code>, and get parent ID through <code>getppid</code>.</li><li>if its \(-1\), something failed</li></ul><h2 id=things-that-are-duplicated>things that are duplicated</h2><ul><li>fire descriptor table</li><li>mapped memory regions (both stack and heap)</li></ul><h2 id=shell>shell</h2><p>a <a href=#shell>shell</a> forks off a child to run the command.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>true</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>char</span> <span style=color:#f92672>*</span><span style=color:#111>command</span> <span style=color:#f92672>=</span> <span style=color:#d88200>&#34;ls&#34;</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>pid_t</span> <span style=color:#111>child_pid</span> <span style=color:#f92672>=</span> <span style=color:#75af00>fork</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#f92672>!</span><span style=color:#111>child_pid</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this is the child
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75af00>run_command</span><span style=color:#111>(</span><span style=color:#111>command</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75af00>exit</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>wait_to_finish</span><span style=color:#111>(</span><span style=color:#111>child_pid</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do cleanup
</span></span></span></code></pre></div><h2 id=fork-mechanics>fork mechanics</h2><p>The act of copying stack and heap sounds really really expensive. So&mldr;. Whapppens?</p><p>Each program thinks its is given all memory addresses to use; the OS maps the &ldquo;virtual addresses&rdquo; to the main address. So, when the fork happens, the virtual address space stays the same. The child will map the parent&rsquo;s memory addresses to <strong>different</strong> physical addresses than for the parent.</p><p>The copies are <strong>LAZY</strong>&mdash;if the child writes to an area in memory, its virtual address are mapped to different addresses. If no writes by the child happen, the virtual address are mapped to the same address.</p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>