<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS242 SEP242024</title>
<meta name=description content="&ldquo;the ways in which one can dividing the original program together depends on the way people can glue problems together. one must provide new kinds of glue in teh programming language&rdquo;
Goals of PL
balancing between:

productivity&mdash;Python
safety&mdash;Coq, Lean
performance&mdash;C,

Edges:

safety+performance&mdash;Rust (not really productive)
productivity+safety&mdash;ML, Maskell (not very performant)
productivity+performance&mdash;Matlab (not very safe)

Java and C++ tries to do all three, but makes them more contradictory systems because you can&rsquo;t get optimality on all three"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS242 SEP242024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#goals-of-pl>Goals of PL</a></li><li><a href=#key-challenges-of-pl>key challenges of PL</a><ul><li><a href=#end-of-the-moore-s-law>end of the Moore&rsquo;s law</a></li></ul></li><li><a href=#history-of-programming-evolution-evolution>history of programming evolution evolution</a><ul><li><a href=#theory>theory</a></li><li><a href=#evolution-of-turing-type-languages>evolution of Turing-type languages</a></li><li><a href=#evolution-of-church-type-languages>evolution of Church-type languages</a></li></ul></li><li><a href=#why-hasn-t-church-languages-taken-over>why hasn&rsquo;t church languages taken over?</a></li><li><a href=#change>change!</a></li></ul></nav></aside><main><article><div><p>&ldquo;the ways in which one can dividing the original program together depends on the way people can glue problems together. one must provide new kinds of glue in teh programming language&rdquo;</p><h2 id=goals-of-pl>Goals of PL</h2><p>balancing between:</p><ul><li>productivity&mdash;Python</li><li>safety&mdash;Coq, Lean</li><li>performance&mdash;C,</li></ul><p>Edges:</p><ul><li>safety+performance&mdash;Rust (not really productive)</li><li>productivity+safety&mdash;ML, Maskell (not very performant)</li><li>productivity+performance&mdash;Matlab (not very safe)</li></ul><p>Java and C++ tries to do all three, but makes them more contradictory systems because you can&rsquo;t get optimality on all three</p><h2 id=key-challenges-of-pl>key challenges of PL</h2><ul><li>developers are reading, not writing</li><li>hardware is changing + software doesn&rsquo;t exploit it well</li><li>memory bloat is getting worse</li><li>bugs aren&rsquo;t getting any better</li><li>software systems are complex at all scales</li><li>developers mostly comprehend/debug code</li></ul><h3 id=end-of-the-moore-s-law>end of the Moore&rsquo;s law</h3><ul><li>to get more performance: you have to build the hardware differently</li><li>software ways of performance improvement becomes much more important</li></ul><h2 id=history-of-programming-evolution-evolution>history of programming evolution evolution</h2><h3 id=theory>theory</h3><ul><li><a href=/posts/kbhturing_machine/>turing machine</a>s designed for studying logic first showed that it is possible to show that some procedural systems don&rsquo;t halt</li><li><a href=/posts/kbhlambda_calculus/>lambda calculus</a> designed for formal logic systems</li></ul><h3 id=evolution-of-turing-type-languages>evolution of Turing-type languages</h3><h4 id=initial-implementation>initial implementation</h4><ul><li>Von Neumann designed the idea of <a href=/posts/kbhturing_machine/>turing machine</a>s being able to be implemented</li><li>Grace hopper designed the idea of higher-level programming abstractions (i.e. tape code, etc.)</li></ul><h4 id=fortran>FORTRAN</h4><p>John Backus got quick adoption of FORTRAN, replacing much of assembly</p><h4 id=algol>Algol</h4><p>Derivation of FORTRAN, very European theory work: decoration, conditionals, global/local variables, block programming, etc.</p><h4 id=c>C</h4><p>The OS community took Algol and try to strip it down to bare basics for low-level features, and also try to make it type safe</p><h4 id=simula>SIMULA</h4><p>New simulation language: the first object-oriented system&mdash;inspired by ALGOL and other such efforts. This was super duper slow.</p><h4 id=c-plus-plus>C++</h4><p>C++ was C&rsquo;s reaction to SIMULA.</p><h4 id=java>Java</h4><p>This was near the advent of Internet.</p><p>Java was a reaction to C++&rsquo;s lack of garbage collection, manual memory collection, made it aggressively more objective oriented, and tried to fix its lack of portability, security, distributed programming, and threading.</p><h4 id=python>Python</h4><p>Python is a reaction to C++ and a desire</p><h3 id=evolution-of-church-type-languages>evolution of Church-type languages</h3><h4 id=lisp>LISP</h4><p>&ldquo;I didn&rsquo;t understand the rest of [Chruch&rsquo;s] book&rdquo;</p><p>but took lambda calculus</p><h4 id=iswim>ISWIM</h4><p>ISWIM&mdash;a typed-ish LISP</p><h4 id=ml>ML</h4><p>a formal, basic functional language , supporting ideas of induction, etc.</p><h4 id=haskell>Haskell</h4><p>lazy evaluation, call by name lambda calculus, infinite structures, etc.</p><h2 id=why-hasn-t-church-languages-taken-over>why hasn&rsquo;t church languages taken over?</h2><ul><li>computers, for the most part, are Turing machines</li><li>church languages, back in the day, didn&rsquo;t fit and didn&rsquo;t finish in a long time</li></ul><p>Alex protip of making a new programming language: you can throw away all the semantics, but keep syntax the same.</p><p>But, machines don&rsquo;t like <a href=/posts/kbhturing_machine/>turing machine</a>s any more: Turing languages are actually pretty bad at that.</p><h2 id=change>change!</h2><ul><li>software systems tend to be big, slow, and buggy</li><li>broad forces are having compelling changes<ul><li>security is a problems => <strong>let&rsquo;s design better verification systems</strong></li><li>revolution is happening in underlying hardware (they are not <a href=/posts/kbhturing_machine/>turing machine</a>s) => <strong>let&rsquo;s move beyond Turing languages</strong></li><li>we have a shortage of skilled programmers => <strong>let&rsquo;s automate programming</strong></li></ul></li></ul></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>