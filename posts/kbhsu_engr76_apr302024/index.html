<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-ENGR76 APR302024</title><meta name=description content="Discrete Fourier Transform
The matrix operation is computationally intractable as it scales with \(O(N^{2})\). The complexity can be reduced via a Fast-Fourier Transform with \(O(n\log n)\) time.
We can compute the Fourier representation forward and backwards by inverting the Fourier matrix
Source Coding Review
Basic Source
We can just do Huffman Coding directly.
Continuous Real Source
We can quantize the continuous source, and then do Huffman Coding.
Continuous-Time Source
Few strategies to get discrete symbols."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-ENGR76 APR302024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#discrete-fourier-transform--kbhsu-engr76-apr252024-dot-md><a href=HAHAHUGOSHORTCODE1396s0HBHB>Discrete Fourier Transform</a></a></li><li><a href=#source-coding-review--kbhsu-engr76-apr092024-dot-md><a href=HAHAHUGOSHORTCODE1396s1HBHB>Source Coding Review</a></a><ul><li><a href=#basic-source>Basic Source</a></li><li><a href=#continuous-real-source>Continuous Real Source</a></li><li><a href=#continuous-time-source>Continuous-Time Source</a></li></ul></li><li><a href=#lossless-sampling>Lossless Sampling</a></li></ul></nav></aside><main><article><div><h2 id=discrete-fourier-transform--kbhsu-engr76-apr252024-dot-md><a href=/posts/kbhsu_engr76_apr252024/#discrete-fourier-transform>Discrete Fourier Transform</a></h2><p>The matrix operation is computationally intractable as it scales with \(O(N^{2})\). The complexity can be reduced via a Fast-Fourier Transform with \(O(n\log n)\) time.</p><p>We can compute the Fourier representation forward and backwards by inverting the Fourier matrix</p><h2 id=source-coding-review--kbhsu-engr76-apr092024-dot-md><a href=/posts/kbhsu_engr76_apr092024/#source-coding>Source Coding Review</a></h2><h3 id=basic-source>Basic Source</h3><p>We can just do <a href=/posts/kbhhuffman_coding/>Huffman Coding</a> directly.</p><h3 id=continuous-real-source>Continuous Real Source</h3><p>We can quantize the continuous source, and then do <a href=/posts/kbhhuffman_coding/>Huffman Coding</a>.</p><h3 id=continuous-time-source>Continuous-Time Source</h3><p>Few strategies to get discrete symbols.</p><ol><li>sampling: to get discrete points</li><li>quantization: to turn int continuous source symbols to discrete symbol-set</li><li>compression: <a href=/posts/kbhhuffman_coding/>Huffman Coding</a></li></ol><h2 id=lossless-sampling>Lossless Sampling</h2><p><a href=#lossless-sampling>sampling</a> is the task of obtaining discrete time samples of a continuous time signals.</p><p>Suppose we have a finite-period signal \(T\). We know that we can extend it into a \(T\) periodic function model-able by an at-least infinite <a href=/posts/kbhfourier_series/>Fourier Series</a> by an repeated extension.</p><p>Moreover, <strong>assume</strong> that the spectrum of the signal can be represented by a <strong>finite</strong> sequence <a href=/posts/kbhfourier_series/>Fourier Series</a>&mdash;essentially, we assume that our signal is a <a href=/posts/kbhsu_engr76_apr252024/#finite-bandwidth-signal>Finite-Bandwidth Signal</a>, and moreover the \(f_{\min} = 0\), and \(f_{\max} = B &lt; \infty\).</p><p>By making the assumption above, we know that our resulting Fourier series has a frequency bounded by \(\frac{j}{T} \leq B \implies j \leq BT\), meaning, this gives:</p><p>\begin{align}
&amp;f(x) = b_0 + \sum_{k=1}^{\infty} \qty( a_{k} \cos(k \omega x) + b_{k} \sin(k \omega x)) \\
\Rightarrow\ & f(x) = b_0 + \sum_{k=1}^{BT} \qty( a_{k} \cos(k \omega x) + b_{k} \sin(k \omega x))
\end{align}</p><p>Now, let us consider what would happen if we tried to sample this signal every \(S\) second:</p><p>at \(x=0\)</p><p>\begin{equation}
y_0 = b_0 + \sum_{j=1}^{BT} a_{j} \sin 0 + b_{j} \cos 0 = b_0 + b_1 + \dots + b_{BT}
\end{equation}</p><p>at \(x=S\)</p><p>\begin{equation}
y_{S} = b_0 + \sum_{j=1}^{BT} a_{j} \sin \qty(2 \pi \frac{j}{T} S ) + b_{j} \cos \qty(2\pi \frac{j}{T} S)
\end{equation}</p><p>&mldr;</p><p>you will note that we have \(2BT + 1\) unknowns (\(b_0, b_1, &mldr;, b_{BT}, a_{1}&mldr;, a_{BT}\)). This means that we need to at least make \(2BT+1\) samples. This means that we need to choose our \(S\) such that:</p><p>\begin{equation}
\frac{T}{S} \geq 2BT + 1 \implies S \leq \frac{T}{2BT+1} \approx \frac{T}{2BT} = \frac{1}{2B}
\end{equation}</p><p>meaning we can reconstruct our whole function as long as our sampling is at least double the <a href=/posts/kbhsu_engr76_apr252024/#bandwidth>Bandwidth</a> of our signal. This is the <a href=#lossless-sampling>nyquist limit</a>.</p><p>We state this more formally in <a href=/posts/kbhsu_engr76_may022024/#nyquist--org0419f3b--sampling-theorem>nyquist sampling theorem</a></p></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>