<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>clock algorithm</title><meta name=description content="in demand paging, if we have to kick out a page, which one do we kick?
possible basic approaches

random page (this works surprisingly well)
throw out the page that&rsquo;s the longest in memory (this is BAD because if a page is there for a long time, its probably accessed a lot)
oracle (pick the page whose next accesses is farest in the future&mldr; we can&rsquo;t predict the future)
LRU (replace the page that&rsquo;s accessed longest time ago)

LRU sounds decently good, but recall that \(2^{36}\) wall times to store wall time for each page are needed which is bad"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>clock algorithm</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#possible-basic-approaches>possible basic approaches</a></li><li><a href=#clock-algorithm>clock algorithm</a></li><li><a href=#page-replacement-model>page replacement model</a><ul><li><a href=#per-process-replacement>per-process replacement</a></li><li><a href=#global-replacement>global replacement</a></li></ul></li><li><a href=#recall-demand-paging>recall: demand paging</a></li></ul></nav></aside><main><article><div><p>in <a href=/posts/kbhdemand_paging/>demand paging</a>, if we have to kick out a page, which one do we kick?</p><h2 id=possible-basic-approaches>possible basic approaches</h2><ul><li>random page (this works surprisingly well)</li><li>throw out the page that&rsquo;s the longest in memory (this is BAD because if a page is there for a long time, its probably accessed a lot)</li><li>oracle (pick the page whose next accesses is farest in the future&mldr; we can&rsquo;t predict the future)</li><li>LRU (replace the page that&rsquo;s accessed <strong>longest time ago</strong>)</li></ul><p><strong>LRU</strong> sounds decently good, but recall that \(2^{36}\) wall times to store wall time for each page are needed which is bad</p><h2 id=clock-algorithm>clock algorithm</h2><p><strong>rotate through all pages until we find one that hasn&rsquo;t been referenced since last time</strong></p><ol><li>we add a <strong>reference bit</strong> to the <a href=/posts/kbhvirtual_memory/#paging>page table</a>&mdash;its set to \(1\) if the program wrote or read each page, otherwise its set to \(0\)</li><li>when page kick is needed, clock algorithm starts where it left off before and scan through physical pages<ol><li>each page it checks with reference bit 1, it sets the <strong>reference bit</strong> as 0</li><li>if it checked a page and its reference bit is 0, we kick it out (because we&rsquo;ve gone through two )</li></ol></li></ol><p>We now <strong>save the position of the hand</strong>&mdash;we want to begin checking with the page that hasn&rsquo;t been checked for the longest time.</p><p>If every page has a <strong>reference bit</strong> is one, running this algorithm doesn&rsquo;t break because it would set its immediately next bit of memory.</p><h2 id=page-replacement-model>page replacement model</h2><h3 id=per-process-replacement>per-process replacement</h3><p><strong>THIS IS NOT USED</strong>: we only kick out our own pages (but&mldr; how would we know how many pages we allocate max per process before we start kicking?).</p><h3 id=global-replacement>global replacement</h3><p><strong>THIS IS USED</strong>: a page fault in one process can kick out a page from another process. all pages from all processes in a single pool.</p><h2 id=recall-demand-paging>recall: demand paging</h2><p>get space:</p><ol><li>pick a page to kick out</li><li>write it to disk</li><li>mark the old page map entry as &ldquo;not present&rdquo;</li><li>update the new page map entry for the new process + point to our reused page</li></ol><hr><p>restore kicked page:</p><ol><li>trigger page fault</li><li>check swap (if it isn&rsquo;t present, page fault end)</li><li>get a new physical page by kicking another page out</li><li>load the data from disk into that reused page</li><li>update page map yet again</li></ol></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>