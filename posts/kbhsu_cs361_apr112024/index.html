<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@100;300;400;500;700&family=IBM+Plex+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100;0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS361 APR112024</title><meta name=description content="Hyper-gradient Descent
Adapt the execution of gradient descent to Hyper-gradient Descent! Recall the Descent Direction Iteration update rule:
For LR \(\alpha\), what if we write:
\begin{equation}
\pdv{f\qty(x^{(k+1)})}{\alpha} = \pdv{f(x^{(k+1)}}{x^{(k+1)}} \pdv{x^{(k+1)}}{\alpha}
\end{equation}
The left side is just \(f&rsquo;(x^{(k+1)}) = \nabla_{x}f(x^{(k+1)})\). Recall that the right side is \(\pdv{\alpha} \qty(x^{(k)} - \alpha \nabla_{x} f(x^{(k)}))\). This evaluates to simply \(-\nabla_{x}f(x^{(k)})\).
Therefore:
\begin{align}
\pdv{f\qty(x^{(k+1)})}{\alpha} &= \pdv{f(x^{(k+1)}}{x^{(k+1)}} \pdv{x^{(k+1)}}{\alpha}  \\
&= \nabla_{x}f(x^{(k+1)}) \cdot (-\nabla_{x}f(x^{(k)}))
\end{align}
And so, to update our step size/learning rate, we can:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/syntax.css></head><body><div class=center-clearfix><header><span id=header-name onclick='window.location.href="/"' style=cursor:pointer>Houjun Liu</span><div id=socialpanel><a href=https://www.jemoka.com/search/ class=header-social id=header-search><i class="ic fa-solid fa-magnifying-glass"></i></i></a>
<a href=https://github.com/Jemoka/ class=header-social id=header-github><i class="ic fa-brands fa-github"></i></a>
<a href=https://maly.io/@jemoka class=header-social id=header-twitter><i class="ic fa-brands fa-mastodon"></i></a>
<a href=https://www.reddit.com/user/Jemoka/ class=header-social id=header-reddit><i class="ic fa-brands fa-reddit"></i></a></div></header><div id=title><h1>SU-CS361 APR112024</h1><span class=tagbox></span></div><aside id=toc><h1 id=toc-title>table of contents</h1><nav id=TableOfContents><ul><li><a href=#hyper-gradient-descent>Hyper-gradient Descent</a></li><li><a href=#second-order-methods>Second-Order Methods</a><ul><li><a href=#newton-s-method>Newton&rsquo;s Method</a></li><li><a href=#secant-method>Secant Method</a></li></ul></li><li><a href=#direct-methods>Direct Methods</a><ul><li><a href=#cyclic-coordinate-search>Cyclic Coordinate Search</a></li><li><a href=#powell-s-method>Powell&rsquo;s Method</a></li><li><a href=#hooke-jeeves-search>Hooke-Jeeves Search</a></li><li><a href=#generalized-pattern-search>Generalized Pattern Search</a></li><li><a href=#nelder-mead-simplex-method>Nelder-Mead Simplex Method</a></li></ul></li></ul></nav></aside><main><article><div><h2 id=hyper-gradient-descent>Hyper-gradient Descent</h2><p>Adapt the execution of <a href=/posts/kbhlogistic_regression/#gradient-descent>gradient descent</a> to <a href=#hyper-gradient-descent>Hyper-gradient Descent</a>! Recall the <a href=/posts/kbhsu_cs361_apr092024/#descent-direction-iteration>Descent Direction Iteration</a> update rule:</p><p>For LR \(\alpha\), what if we write:</p><p>\begin{equation}
\pdv{f\qty(x^{(k+1)})}{\alpha} = \pdv{f(x^{(k+1)}}{x^{(k+1)}} \pdv{x^{(k+1)}}{\alpha}
\end{equation}</p><p>The left side is just \(f&rsquo;(x^{(k+1)}) = \nabla_{x}f(x^{(k+1)})\). Recall that the right side is \(\pdv{\alpha} \qty(x^{(k)} - \alpha \nabla_{x} f(x^{(k)}))\). This evaluates to simply \(-\nabla_{x}f(x^{(k)})\).</p><p>Therefore:</p><p>\begin{align}
\pdv{f\qty(x^{(k+1)})}{\alpha} &= \pdv{f(x^{(k+1)}}{x^{(k+1)}} \pdv{x^{(k+1)}}{\alpha} \\
&= \nabla_{x}f(x^{(k+1)}) \cdot (-\nabla_{x}f(x^{(k)}))
\end{align}</p><p>And so, to update our step size/learning rate, we can:</p><p>\begin{align}
\alpha^{(k+1)} &= \alpha^{(k)} - \mu \qty(\pdv{f\qty(x^{(k+1)})}{\alpha}) \\
&= \alpha^{(k)} - \mu \qty[\nabla_{x}f(x^{(k+1)}) \cdot (-\nabla_{x}f(x^{(k)}))] \\
&= \alpha^{(k)} + \mu \qty[\nabla_{x}f(x^{(k+1)}) \cdot (\nabla_{x}f(x^{(k)}))]
\end{align}</p><p>Therefore, we <strong>update our weights</strong> based on steps of \(\alpha\), and update our learning rate too with respect to minimizing \(f\). You will note that <strong>optimal step sizes</strong> results in gradients being orthogonal; we see that this reflects this&mdash;no updates to \(\alpha\) happen if the gradients from \((k+1)\) is orthogonal to \(k\).</p><h2 id=second-order-methods>Second-Order Methods</h2><h3 id=newton-s-method>Newton&rsquo;s Method</h3><p>See <a href=/posts/kbhnewton_s_method/>Newton&rsquo;s Method</a></p><h3 id=secant-method>Secant Method</h3><p>You can estimate the <a href=/posts/kbhsu_math53_feb212024/#hessian>Hessian</a> from the gradient to apply <a href=/posts/kbhnewton_s_method/>Newton&rsquo;s Method</a>; this requires doing a thing:</p><p>\begin{equation}
f&rsquo;&rsquo;(x_{k}) \approx \frac{f&rsquo;(x_{k}) - f&rsquo;(x_{k-1})}{x_{k} - x_{k-1}}
\end{equation}</p><p>Now, we can write:</p><p>\begin{equation}
x_{t+1} = x_{t} - \frac{x_{t} - x_{t-1}}{f&rsquo;(x_{t}) -f&rsquo;(x_{t-1})} f&rsquo;(x_{t})
\end{equation}</p><p>How do we do this for Hessian? Use one of&mdash;</p><ul><li><a href=/posts/kbhdavidson_fletcher_powell_dfp/>Davidson-Fletcher-Powell (DFP)</a></li><li><a href=/posts/kbhbroyden_fletcher_goldfarb_shanno_bfgs/>Broyden-Fletcher-Goldfarb-SHanno (BFGS)</a></li><li><a href=/posts/kbhlimited_memory_bfgs/>Limited Memory BFGS</a></li></ul><p>due to approximate nature, this may take more steps to converge.</p><h2 id=direct-methods>Direct Methods</h2><h3 id=cyclic-coordinate-search>Cyclic Coordinate Search</h3><p><strong>cycle</strong> through the <strong>coordinates</strong> and do line <strong>search</strong>. For a function that has \(n\) design variables in the design point. In each iteration, we freeze all dimensions except one, do line search, then move on to the next coordinate frame, and repeat.</p><h4 id=broken>Broken</h4><p>This may fail when there is a trough <strong>between</strong> two axes</p><h4 id=accelerated-coordinate-search>Accelerated Coordinate Search</h4><p>After taking \(n\) cycles through all the directions once, also take a step in the average of the directions of the previous \(n\) steps. This kinda fixes the case where there&rsquo;s a trough in between.</p><h3 id=powell-s-method>Powell&rsquo;s Method</h3><p>This is <a href=#accelerated-coordinate-search>Accelerated Coordinate Search</a>, but we forget the oldest search direction. Consider <a href=#cyclic-coordinate-search>Cyclic Coordinate Search</a>, which searches in steps of the basis vectors \(e^{1}, e^{2}, &mldr;, e_{n}\). <a href=#accelerated-coordinate-search>Accelerated Coordinate Search</a> searches in \(e^{1} &mldr; e^{n}, d\), where \(d\) is the averages of your previous steps.</p><p><a href=#powell-s-method>Powell&rsquo;s Method</a> go once forward by dropping the first member of the list</p><ul><li>\(e^{1} &mldr; e^{n}, d^{(1)}\)</li><li>\(e^{2}, &mldr;, e^{n}, d^{(1)}, d^{(2)}\)</li><li>\(e^{3}, &mldr;, e^{n}, d^{(1)}, d^{(2)}, d^{(3)}\)</li></ul><h4 id=failure>Failure</h4><p>This may rapidly result in linearly dependent variables due to so much averaging. We therefore perform a linear search to obtain a new \(d\) or just reset this list back to independent bases every so often.</p><h3 id=hooke-jeeves-search>Hooke-Jeeves Search</h3><p>See <a href=/posts/kbhlocal_policy_search/>Hooke-Jeeves Policy Search</a>, but you don&rsquo;t check the <a href=/posts/kbhrollout_with_lookahead/#rollout-policy>Rollout Policy</a>; you just go and evaluate the function.</p><p>big picture: check a set of local perturbations, move your center point to the lowest one, and perturb again. If you converge, shrink your perturbation size.</p><h3 id=generalized-pattern-search>Generalized Pattern Search</h3><p><a href=#hooke-jeeves-search>Hooke-Jeeves Search</a> uses \(2n\) searches, one in each direction; for \(\mathbb{R}^{2}\), for instance, this requires \(4\) lookups because 2 basis, and one sample in positive and one sample in negative direction.</p><p>So, to save one lookup, we create a positive spanning set instead (i.e. <a href=/posts/kbhspan/#spans>spanning</a> set for the space for which you are constrained to only use positive coefficients, meaning we need one more vector). This creates a &ldquo;triangle&rdquo; which requires \(n+1\) vectors, but we only check one point per <a href=/posts/kbhspan/#spans>spanning</a> set member.</p><h4 id=opportunistic-search>Opportunistic Search</h4><p>If you get a minimum point, just go there.</p><h4 id=dynamic-ordering>Dynamic Ordering</h4><p>If you found a minimum point once, check that point again first after going there.</p><h3 id=nelder-mead-simplex-method>Nelder-Mead Simplex Method</h3><p>Take a simplex to search. Sort its verticies by lowest to highest in terms of objective function value, with lowest point being called \(x_{l}\), the \(x_{h}\) the highest function value, \(x_{s}\) being the second highest function value. \(\bar{x}\) being the mean point between all points except \(x_{h}\).</p><p>You have four possible actions</p><ul><li><strong>reflection</strong>: take your worst point, and reflex across the mean line formed across the remaining points</li><li><strong>expansion</strong>: take your best point, and move them</li><li><strong>contraction</strong>: move the worst point closer to the mean of the other two</li><li><strong>shrink</strong>: move all points closer together</li></ul></div></article></main><footer><p id=footer>&copy; 2019-2024 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div></body></html>